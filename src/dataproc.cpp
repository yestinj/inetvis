#include <dataproc.h>
#include <iostream>
#include <stdio.h>
#import <QSettings>
#import "log.h"

/*******************************************************************
InetVis - Internet Visualisation
Version: 2.1.0
release date: 2017/09/21

Original Authors: Jean-Pierre van Riel, Barry Irwin
Initvis 2.x Authors: Yestin Johnson, Barry Irwin
Rhodes University
Computer Science Honours Project - 2005
Computer Science Masters Project - 2006/7
Computer Science Masters Project - 2017
author: Jean-Pierre van Riel
supervisor: Barry Irwin

InetVis - Internet Visualisation for network traffic.
Copyright (C) 2006-2017, Jean-Pierre van Riel, Barry Irwin, Yestin Johnson

*******************************************************************/

using namespace std; //for debugging purposes

/* libpcap pcap_pkthdr definition for reference purposes

   struct pcap_pkthdr
   {
      struct timeval ts; //time stamp
      bpf_u_int32 caplen; //length of portion present
      bpf_u_int32 len; //length this packet (off wire)
   };

*/


//DataExtractor ---------------------------------------------------------------


//DataExtractor Constructor and destructor ----------------


DataProcessor *DataProcessor::DataExtractor::statDataProcessor;


DataProcessor::DataExtractor::DataExtractor()
{
    //by default, the data extracor is set to monitor the defaul local device

    if (!PacketHeaders::testDataPrimativeSizes())
    {  reportError("underlyting primitive data sizes are incompatible with this programs data structures",
                   "DataExtractor::DataExtractor()");
        qFatal("underlyting primitive data sizes are incompatible with this programs data structures");
        exit(1);
    }

    pcapErrorBuffer[0] = '\0'; //init pcap error buffer to empty string

    //init string descriptions of data sources
    strReplayFileReference = QString();
    strRecordFileReference = QString(DEFAULT_DUMP_FILE_NAME);
    strLocalInterface = QString();
    strServerAddress = QString();

    pcapRet = 0; //to hold return values from pcap
    packetCaptureLength = CAPTURE_LENGTH; //number of starting bytes to
    //capture for packet packet event buffer
    promiscuousMode = PROMISC_MODE; //1 = promisc mode, 0 = non-promisc mode
    readTimeout = NO_READ_TIMEOUT; //in millisec

    //init pcap components
    allDevices = NULL;
    device = NULL;
    fileCaptureInstance = NULL;
    liveCaptureInstance = NULL;
    dataLinkType = DATA_LINK_UNSET;
    dumpFileDescriptor = NULL;
    recMode = CONTINUOUS;

    //init network info
    netAddress = 0; //IP network address
    netMask = 0; //IP subnet mask

    //init filter expression
    implicit_bpf_FilterExpr = QString(IMPLICIT_BPF_FILTER_EXP);
    bpfFilterExpr = QString(); //init to a null string
    //bpfFilterProgram struct not yet initialized untill valid capture instance
    //exists

}


DataProcessor::DataExtractor::~DataExtractor()
{
    //ensure cleanup

    pcap_freealldevs(allDevices); //free list generated by find all devices

    if (dumpFileDescriptor != NULL)
    {
#ifdef DEBUG_RECORD_PACKETS
        cerr << "DEBUG: automatically closing dump file on program exit\n";
#endif

        closeDumpFile();
        //will automatically stop playback and close file
    }

    if (liveCaptureInstance != NULL)
    {
#ifdef DEBUG_CAPTURE_INSTANCE
        cerr << "DEBUG: live capture instance not null (presumably not closed yet), now closing: "
             << liveCaptureInstance << '\n';
#endif

        pcap_close(liveCaptureInstance);
    }

    if (fileCaptureInstance != NULL)
    {
#ifdef DEBUG_CAPTURE_INSTANCE
        cerr << "DEBUG: file capture instance not null (presumably not closed yet), now closing: "
             << fileCaptureInstance << '\n';
#endif

        pcap_close(fileCaptureInstance);
    }

}


//DataExtractor private methods ---------------------------


void DataProcessor::DataExtractor::readCaptureFile()
{
    struct pcap_pkthdr *pt_pcapHeader;
    const u_char *pt_snapshot;
    bool processPackets = true;

#ifdef DEBUG_PACKETS_PROCESSED
    int packetsRead = 0;
#endif

#ifdef DEBUG_DATA_EXTRACTOR
    //this method should not be called if a capture file has not been opened
    if (fileCaptureInstance == NULL)
    {  //capture instacnce invalid
        reportError("file capture instance is null, unable to process file",
                    "DataExtractor::readCaptureFile()");
        return;
    }
#endif

    //firstly, check that the last packet in the buffer is within the current
    //buffer time frame - in some cases, an update will be called, but since
    //we grab at lest one packet in advance, that packet may still be ahead
    //of the buffer position - this avoids accumulating an off by one error
    if (!dataProcessor->packetEventBuffer.empty())
    {  if (TimeUtil::timevalGreaterThan(
                    dataProcessor->packetEventBuffer.front().timeStamp,
                    dataProcessor->bufferPosition))
            return;
    }

    //process cap file, reading packets into buffer up till buffer ahead time is
    //reached - this will always result in the buffer containing one extra packet
    //beyond the buffer time range

    do
    {  pcapRet = pcap_next_ex(fileCaptureInstance, &pt_pcapHeader, &pt_snapshot);
        //check result
        if (pcapRet == 1)
        {  //sucessful read

#ifdef DEBUG_PACKETS_PROCESSED
            packetsRead++;
#endif

            //for asituations where we seek ahead, check if we are inside the time
            //range for the buffer, else loop untill we are within the buffer range
            if (TimeUtil::timevalGreaterThan(pt_pcapHeader->ts,
                                             dataProcessor->timeWindowEnd))
            {  //process packet into buffer
                DataExtractor::processPacket(NULL, pt_pcapHeader, pt_snapshot);
                //check to see if we have passed the buffer position yet
                if (TimeUtil::timevalGreaterThan(pt_pcapHeader->ts,
                                                 dataProcessor->bufferPosition))
                {  //buffer is up to desired position, no more processing need be
                    //done
                    processPackets = false;
                }
            }
        }
        else
        {  if (pcapRet == -2) //end of the file
            {
#ifdef DEBUG_DATA_EXTRACTOR
                QDateTime capEndTm;
                TimeUtil::timevalToQDateTime(capEndTm,
                                             dataProcessor->captureEndTime);
                cerr << "DEBUG: replay file end reached at: "
                     << capEndTm.toString().toLatin1().data() << '\n';
#endif

                //close file
                //beacuse we may be filtering, there may still be excluded events,
                //so we dont want to stop unless at end time
                if (TimeUtil::timevalGreaterThan(dataProcessor->timeWindowEnd,
                                                 dataProcessor->captureEndTime))
                {  dataProcessor->replayState = REPLAY_AT_END;
                }
            }
            else //error handling
            {
#ifdef DEBUG_DATA_EXTRACTOR
                if (pcapRet == 0)
                { //packets are being read from a live capture, and the timeout
                    //expired - this case should never arise when reading a file
                    reportError("live capture error that should not occur when reading a file",
                                "libpcap::pcap_next_ex()");
                    processPackets = false;
                }
#endif

                if (pcapRet == -1)
                {  //error reading next packet
                    reportError("error whilst trying to read next packet from file",
                                "libpcap::pcap_next_ex()");
                    //try continue reading packets
                }
            }
            //stop processing
            processPackets = false;
        }
    }
    while (processPackets);

#ifdef DEBUG_PACKETS_PROCESSED
    cerr << "DEBUG: packets read from file = " << packetsRead << '\n';
#endif

}


void DataProcessor::DataExtractor::monitorLocalHost() {

    /* TODO: This method may lend itself to a threaded implimentation given the
   following warning in the pcap man file:
   "when reading a live capture, pcap_dispatch() will not necessarily return
   when the read times out; on some platforms, the read timeout isn't supported,
   and, on other platforms, the timer doesn't start until at least one packet
   arrives. This means that the read timeout should NOT be used in, for example,
   an interactive application, to allow the packet capture loop to ``poll'' for
   user input periodically, as there's no guarantee that pcap_dispatch() will
   return after the timeout expires"
*/

#ifdef DEBUG_DATA_EXTRACTOR
    //this method should not be called if a live apture interface has not been
    //opened
    if (liveCaptureInstance == NULL) {
        //capture instacnce invalid
        reportError(("capture instance is null, unable to monitor on local interface"
                     + strLocalInterface), "DataExtractor::monitorLocalHost()");
        dataProcessor->pause();
        dataProcessor->setMode(NOT_READY);
        return;
    }
#endif

    //process off network interface, reading packets into buffer up till timeout
    //value is reached

#define CNT_PROCESS_ALL_PACKETS -1
    pcapRet = pcap_dispatch(liveCaptureInstance, CNT_PROCESS_ALL_PACKETS,
                            processPacket, NULL);
    //should be set to non blocking mode, so pcap_dispatch will return if there
    //are no packets to be read

    if (pcapRet >= 0) {
        //packets processed no more to be done for now
        //update the capture end time and buffer position

        PacketEvent *pe;
        pe = &dataProcessor->packetEventBuffer.front();
#ifdef DEBUG_DATA_RENDER
        cerr << "DEBUG: Succefully returning from monitoring interface, with no further packets to process for the moment\n";
#endif
        return;
    }

    if (pcapRet == -2) {
#ifdef DEBUG_DATA_RENDER
        cerr << "DEBUG: monitoring was interupted by pcap_breakloop() call before any packets could be processed\n";
#endif
        return;
    }

    if (pcapRet == -1) {
        strcpy(pcapErrorBuffer, pcap_geterr(liveCaptureInstance)); //copy error into
        //error buffer
        reportError(("error monitoring off interface " + strLocalInterface),
                    "libpacp::pcap_dispatch()");
        return;
    }
}


void DataProcessor::DataExtractor::monitorRemoteServer() {
    //TODO: open a socket and recieve data updates from a server capturing
    //packets
}


void DataProcessor::DataExtractor::processPacket(u_char *args,
                                                 const struct pcap_pkthdr *header, const u_char *snapshot) {

    //this method is static to allow access to libpacp and be used as a
    //pcap_handler callback function. statDataProcessor needs to be correctly
    //assigned before using this function

    //the function call below creates a PacketEvent object. When the object is
    //created, the data in header and snapshot is copied and parsed into
    //header structures which index the binary data - see packetevent.h and
    //packetheaders.h. The new object is then placed in the deque which is
    //ordered by timestamps.
    statDataProcessor->packetEventBuffer.push_front(PacketEvent(header, snapshot));
    //the function call below takes the newly added packet and plots the graphic
    //element from the data in the object - see plot.h and graphic element.h
    Plotter::plot(statDataProcessor->packetEventBuffer.front());

    //packet recording
    if (statDataProcessor->recordToFile) {
        //record while within time window start
            if (TimeUtil::timevalGreaterThan(header->ts,
                                         statDataProcessor->timeWindowEnd))
        {  //check to ensure value not previously recorded
            if (TimeUtil::timevalGreaterThan(header->ts,
                                             statDataProcessor->lastRecordTime))
            {  //set last record time to current pakcet
                statDataProcessor->lastRecordTime.tv_sec = header->ts.tv_sec;
                statDataProcessor->lastRecordTime.tv_usec = header->ts.tv_usec;
                pcap_dump((u_char*)statDataProcessor->dataExtractor.dumpFileDescriptor,
                          header, snapshot);

#ifdef DEBUG_RECORD_PACKETS
                QDateTime timeStamp;
                TimeUtil::timevalToQDateTime(timeStamp, header->ts);
                cerr << "DEBUG: write packet to file with timestamp = "
                     << timeStamp.toString("yyyy/MM/dd - hh:mm:ss:zzz").toLatin1().data() << '\n';
#endif

            }
        }
    }

    //set transparent decay if necessary
    if (statDataProcessor->transDecay)
    {  if (TimeUtil::timevalGreaterThan(
                    statDataProcessor->packetEventBuffer.front().timeStamp,
                    statDataProcessor->replayPosition))
        {  //to be display fully opacit when in time window
            statDataProcessor->packetEventBuffer.front().point.colour[3] = 1.0;

#ifdef DEBUG_TRANS_DECAY
            QDateTime dtTemp;
            TimeUtil::timevalToQDateTime(dtTemp,
                                         statDataProcessor->packetEventBuffer.front().timeStamp);
            cerr << "DEBUG: Transparent Decay"
                 << "\n   packet time stamp = "
                 << dtTemp.toString("yyyy/MM/dd-hh:mm:ss:zzz")
                 << "\n   replay position   = "
                 << statDataProcessor->qdt_replayPosition.toString("yyyy/MM/dd-hh:mm:ss:zzz")
                 << "\n   time window end   = "
                 << statDataProcessor->qdt_twEnd.toString("yyyy/MM/dd-hh:mm:ss:zzz")
                 << "\n   alpha = "
                 << statDataProcessor->packetEventBuffer.front().point.colour[3]
                 << '\n';
#endif

        }
        else
        {  //calculate fraction opacit according to current time and time window
            statDataProcessor->packetEventBuffer.front().point.colour[3] =
                    TimeUtil::relTimeFrac(
                        statDataProcessor->packetEventBuffer.front().timeStamp,
                        statDataProcessor->timeWindowEnd,
                        statDataProcessor->replayPosition);

#ifdef DEBUG_TRANS_DECAY
            QDateTime dtTemp;
            TimeUtil::timevalToQDateTime(dtTemp,
                                         statDataProcessor->packetEventBuffer.front().timeStamp);
            cerr << "DEBUG: Transparent Decay"
                 << "\n   packet time stamp = "
                 << dtTemp.toString("yyyy/MM/dd-hh:mm:ss:zzz")
                 << "\n   replay position   = "
                 << statDataProcessor->qdt_replayPosition.toString("yyyy/MM/dd-hh:mm:ss:zzz")
                 << "\n   time window end   = "
                 << statDataProcessor->qdt_twEnd.toString("yyyy/MM/dd-hh:mm:ss:zzz")
                 << "\n   alpha = "
                 << statDataProcessor->packetEventBuffer.front().point.colour[3]
                 << '\n';
#endif

        }
    }

}


void DataProcessor::DataExtractor::reportError(const QString &errMsg,
                                               const QString &function)
{
    //similar to that of dataprocessor error reporter
    QString errorMessage;
    errorMessage.append("ERROR: ");
    errorMessage.append(errMsg);
    if (!function.isNull() && !function.isEmpty())
    {  errorMessage.append("\n - in function: ");
        errorMessage.append(function);
    }
    if (checkPcapErrorBuffer())
    {  errorMessage.append("\n - pcap error: \"");
        errorMessage.append((const char*)pcapErrorBuffer);
        //QString should make a 'deep' copy (value not reference) of the const
        //char*
        errorMessage.append("\"");
        resetPcapErrorBuffer(); //reset the error buffer after reporting
    }
    errorMessage.append("\n");

#ifdef OUTPUT_ERRORS_STD_OUT
    cerr << errorMessage.toStdString();
#elif DEBUG_DATA_EXTRACTOR
    cerr << errorMessage.toStdString();
#endif

#ifdef OUTPUT_ERRORS_GUI
    emit dataProcessor->sendErrMsg(errorMessage);
#endif

}


//DataExtractor public methods -------------------------------------------------


void DataProcessor::DataExtractor::setDataProcLink(DataProcessor *ptr)
{
    dataProcessor = ptr; //assign pointer to calling DataProcessor
    DataExtractor::statDataProcessor = dataProcessor;

}


bool DataProcessor::DataExtractor::findAllDevices(QStringList &strLstAllDevs)
{
    pcap_if_t *dev;

    //populate list of netowrk devices
    pcapRet = pcap_findalldevs(&allDevices, pcapErrorBuffer);

    if (pcapRet == -1)
    {  reportError("no local interfaces found for live monitoring",
                   "libpcap::pcap_findalldevs");
        return false;
    }

    //clear string list if not empty
    if (!strLstAllDevs.isEmpty())
        strLstAllDevs.clear();

    //generate list of device name strings
    for (dev = allDevices; dev != NULL; dev = dev->next)
    {  strLstAllDevs.append(allDevices->name);
    }

#ifdef DEBUG_DATA_EXTRACTOR
    cerr << "DEBUG: Devices found:\n";
    //print list of devices
    int numDevs = 0;
    for (dev = allDevices; dev; dev = dev->next)
    {  //print device identifier
        cerr << "\t" << ++numDevs << " " << dev->name;
        //print device description
        if (dev->description != NULL)
            cerr << " - " << dev->description << endl;
        else
            cerr << " - no description found\n";
    }
#endif

    //HACK
    resetPcapErrorBuffer(); //for some reason, pcap socet errors are generated

    return true;

}


bool DataProcessor::DataExtractor::setDataLinkType()
{
    if (fileCaptureInstance == NULL && liveCaptureInstance == NULL)
    {  reportError("capture instance was NULL and could not get data link type",
                   "DataExtractor::setDataLinkType()");
        return false;
    }

    if (fileCaptureInstance != NULL)
    {  //assume ethernet cap
        dataLinkType = DLT_EN10MB;

#ifdef DEBUG_DATA_EXTRACTOR
        cerr << "DEBUG: assumed ethernet data link for file capture instance\n";
#endif

    }

    if (liveCaptureInstance != NULL)
        dataLinkType = pcap_datalink(liveCaptureInstance); //returns data link types

    //check for unsupported data link types
    if (dataLinkType == DLT_EN10MB) //list of types supported
    {  //update the static dataLinkType in PacketHeaders
        PacketHeaders::setDataLinkType(DL_ETHERNET);

#ifdef DEBUG_DATA_EXTRACTOR
        cerr << "DEBUG: set data link type (pcap code): " << dataLinkType
             << endl;
#endif

        return true;
    }
    else
    {  reportError("data link type not supported",
                   "DataExtractor::setDataLinkType");
        return false;
    }



}


bool DataProcessor::DataExtractor::lookupNetwork() {
    int ret; //value to hold return code from pcap operations

    if (dataProcessor->getMode() == MONITOR_LOCAL) {
        //live capture, get local net from interface
        //no need to pause since no file io required

        //assert valid interface present
        /*
        if (device == NULL)
        */
        if (liveCaptureInstance == NULL) {  netAddress = 0;
            netMask = 0;
            reportError("device was NULL and cannor lookup network addressing",
                        "DataProcessor::lookupNetwork");
            return false;
        }
        /*
      ret = pcap_lookupnet(device->name, &netAddress , &netMask,
            pcapErrorBuffer);
        */
        ret = pcap_lookupnet(strLocalInterface.toLatin1(), &netAddress , &netMask,
                             pcapErrorBuffer);
        //resolve byte order issue
        netAddress = (bpf_u_int32)ntohl(netAddress);
        netMask = (bpf_u_int32)ntohl(netMask);

        if (ret == -1) {
            netAddress = 0;
            netMask = 0;
            reportError("error looking up network address",
                        "libpcap::pcap_lookupnet");
            return false;
        }

#ifdef DEBUG_LOOKUP_HOME_NET
        if (ret != -1)
            cerr << "DEBUG: set IP network address: "
                 << PacketHeaders::ipAdrToDecDotStr(netAddress)
                 << "; network mask: "
                 << PacketHeaders::ipAdrToDecDotStr(netMask) << endl;
#endif

        dataProcessor->reportHomeNetwork();
        return true;
    }
    else if (dataProcessor->getMode() == REPLAY_FILE) {
        //file replay, scan file for smallest and greatest destination address,
        //then determine home network address range

        //need to pause replay in order to wait for file io
        if (dataProcessor->getState() == PLAYING)
            dataProcessor->pause();

        //file is currently open, reopen it to scan addresses, using seperate
        //file read
        pcap_t *tempCaptureInstance;
        tempCaptureInstance = pcap_open_offline(strReplayFileReference.toLatin1().data(),
                                                pcapErrorBuffer);

        if (tempCaptureInstance == NULL) {
#ifdef DEBUG_CAPTURE_INSTANCE
            cerr << "DEBUG: failed opening second temp file capture instance on file to scan address range: "
                 << tempCaptureInstance << '\n';
#endif
            return false;
        }
        else {
#ifdef DEBUG_CAPTURE_INSTANCE
            cerr << "DEBUG: sucessfully opened second temp file capture instance to scan address range: "
                 << tempCaptureInstance << '\n';
#endif
        }

        //address values
        unsigned int largestIP = 0;
        unsigned int lowestIP = MAX_U_INT32_VAL;
        //packet header data
        struct pcap_pkthdr *pt_pcapHeader = NULL; //hold packet data
        const u_char *pt_snapshot = NULL; //hold raw packet data
        struct OSI_Packet pkt; //to cast header structure

#ifdef DEBUG_DATA_EXTRACTOR
        cerr << "DEBUG: Scanning file for address range check...\n";
#endif

        //read file and scan packets extracting largest and lowest ip values
        ret = pcap_next_ex(tempCaptureInstance, &pt_pcapHeader, &pt_snapshot);
        //return value for pcap
        //check that at least one packet was read correctly
        if (ret != 1) {
            //failed to read even the first packet
            reportError("could not read any packets from file",
                        "libpcap::pcap_next_ex()");
            return false;
        }

        //read the rest of the packets till file ends

#ifdef DEBUG_LOOKUP_HOME_NET
        int pktCounter = 1;
#endif

        while (ret == 1 || ret == -1) {
            if (ret == 1) {
                //parse packet
                PacketHeaders::parsePacket(pkt, (unsigned char*)pt_snapshot,
                                           (int)pt_pcapHeader->caplen);
                //get IP address values
                struct IP_Header *ip;
                ip = (IP_Header*)(pkt.pt_networkHeader);
                if (pkt.dataLinkType == DL_ETHERNET && pkt.networkType == N_IPv4) {
                    //check if IP larger
                    if (ip->dstAddress > largestIP) {
                        largestIP = ip->dstAddress;
                    }
                    //check if IP lower
                    if (ip->dstAddress < lowestIP) {
                        lowestIP = ip->dstAddress;
                    }
                }
            }
            else {
                //error reading packet
                reportError("error whilst trying to read next packet from file",
                            "libpcap::pcap_next_ex()");
            }

#ifdef DEBUG_LOOKUP_HOME_NET
            pktCounter++;
#endif

            //get next packet for continued itteration
            ret = pcap_next_ex(tempCaptureInstance, &pt_pcapHeader, &pt_snapshot);
        }

        //check end status of reading file
        if (ret == -2) //presumably the end of the file
        {
#ifdef DEBUG_DATA_EXTRACTOR
            cerr << "DEBUG: Presumably reached end of file\n";
#endif
        }

#ifdef DEBUG_DATA_EXTRACTOR
        if (ret == 0)
        { //packets are being read from a live capture, and the timeout
            //expired - this case should never arise when reading a file
            reportError("live capture error that should not occur when reading a file",
                        "libpcap::pcap_next_ex()");
            return false;
        }
#endif

        //release resource
#ifdef DEBUG_CAPTURE_INSTANCE
        cerr << "DEBUG: closed second temp file capture instance: " << tempCaptureInstance << '\n';
#endif

        pcap_close(tempCaptureInstance);
        tempCaptureInstance = NULL;

#ifdef DEBUG_LOOKUP_HOME_NET
        cerr << "DEBUG: Finished scanning file for address range check\n";
        cerr << "   Packets    = " << pktCounter << '\n';
        cerr << "   largest IP = "
             << PacketHeaders::ipAdrToDecDotStr(largestIP) << " (= "
             << largestIP << ")\n";
        cerr << "   lowest IP  = "
             << PacketHeaders::ipAdrToDecDotStr(lowestIP) << " (= "
             << lowestIP << ")\n";
#endif

        //find network address and subnet mask from range length of addresses
        //approximate network range length (the largest and smallest addresses
        //are not necessarily the first and last addresses in the network)
        unsigned int rangeSize = largestIP - lowestIP;

#ifdef DEBUG_LOOKUP_HOME_NET
        cerr << "   range length  = " << rangeSize << '\n';
#endif

        //find first bit in range size to infer subnet
        unsigned int bitSearchMask = 0x80000000;
        unsigned int tempNetMask = 0xFFFFFFFF;
        bool bitFound = rangeSize & bitSearchMask; //try very first bit
        //use single bit shifts to change bitSearchMask to find first bit
        int bitCounter = 0;
        if (rangeSize != 0) //check for case where only one address is found
        {  while (!bitFound)
            {  bitCounter++;
                bitSearchMask = bitSearchMask >> 1;
                bitFound = (rangeSize & bitSearchMask) != 0x00000000;
                //at the same time create an inverse of the subnet
            }
        }
        //shift bits of inverseNetMask by number
        tempNetMask = tempNetMask << (32 - bitCounter);
        netMask = (bpf_u_int32)(tempNetMask);
        netAddress = (bpf_u_int32)(lowestIP & netMask);

#ifdef DEBUG_LOOKUP_HOME_NET
        cerr << "DEBUG: Guessed IP network range:\n   network address = "
             << PacketHeaders::ipAdrToDecDotStr(netAddress)
             << "\n   network mask = "
             << PacketHeaders::ipAdrToDecDotStr(netMask) << '\n';
#endif

        dataProcessor->reportHomeNetwork();
        return true;
    }
    else {
        //else failed to acomplish anything
        reportError("Presumably the data processor mode is NOT_READY",
                    "DataExtractor::lookupNetwork()");
        return false;
    }
}


void DataProcessor::DataExtractor::setHomeNetwork(unsigned int netAdr,
                                                  unsigned int mask) {
    netAddress = (bpf_u_int32)netAdr;
    netMask = (bpf_u_int32)mask;

#ifdef DEBUG_DATA_EXTRACTOR
    cerr << "DEBUG: network address set to: "
         << PacketHeaders::ipAdrToDecDotStr(netAdr).toLatin1().data() << ", mask set to: "
         << PacketHeaders::ipAdrToDecDotStr(mask).toLatin1().data() << endl;
#endif

    dataProcessor->reportHomeNetwork();
}


void DataProcessor::DataExtractor::getHomeNetwork(unsigned int &netAdr, unsigned int &mask)
{
    netAdr = (unsigned int)netAddress;
    mask = (unsigned int)netMask;

}


bool DataProcessor::DataExtractor::openCaptureFile(const QString file)
{
    //TODO: custom parsing and indexing of a pcap file would be more efficient,
    //for seeking etc

#ifdef DEBUG_DATA_EXTRACTOR
    cerr << "DEBUG: pcap file open --------------------------------------------------------\n";
#endif

#ifdef DEBUG_PACKETS_PROCESSED
    int packetsRead = 0;
#endif

    //if currently playing, pause
    if (dataProcessor->getState() == PLAYING)
        dataProcessor->pause();

#ifdef DEBUG_DATA_EXTRACTOR
    cerr << "DEBUG: checking for previous open interfaces\n";
#endif

    if (dataProcessor->getMode() == MONITOR_LOCAL || liveCaptureInstance != NULL)
    {
#ifdef DEBUG_CAPTURE_INSTANCE
        cerr << "DEBUG: opening file while live capture interface open: "
             << liveCaptureInstance << '\n';
        cerr << "DEBUG: closing live capture interface: "
             << liveCaptureInstance << '\n';
#endif

        pcap_close(liveCaptureInstance);
        liveCaptureInstance = NULL;
        dataProcessor->packetEventBuffer.clear();
        //dataProcessor->glVisWidget->update();
        dataProcessor->updateGLVisWidget();
    }

    if (dataProcessor->getMode() == REPLAY_FILE || fileCaptureInstance != NULL)
    {
#ifdef DEBUG_CAPTURE_INSTANCE
        cerr << "DEBUG: opening file while file capture interface still open: "
             << fileCaptureInstance << '\n';
        cerr << "DEBUG: closing file capture interface: "
             << fileCaptureInstance << '\n';
#endif

        pcap_close(fileCaptureInstance);
        liveCaptureInstance = NULL;
        dataProcessor->packetEventBuffer.clear();
        //dataProcessor->glVisWidget->update();
        dataProcessor->updateGLVisWidget();
    }

    dataProcessor->setMode(NOT_READY);

    //open a capture file
    if (file.isNull() || file.isEmpty())
    {  //capture file reference not valid
        reportError("file reference is null or empty and therefore not set",
                    "DataExtractor::setReplayFile");
        return false;
    }
    else
    {  strReplayFileReference = file; //set to file reference
    }

#ifdef DEBUG_DATA_EXTRACTOR
    cerr << "DEBUG: opening capture file to scan for start and end timestamps\n";
#endif

    fileCaptureInstance = pcap_open_offline(strReplayFileReference.toLatin1().data(), pcapErrorBuffer);

    if (fileCaptureInstance == NULL)
    {  //capture file not successfully set
        reportError("failed to open capture file '" + file + "'",
                    "libpcap::pcap_open_offline");
        return false;
    }

#ifdef DEBUG_CAPTURE_INSTANCE
    cerr << "DEBUG: capture instance succesfully opened for file scan: "
         << fileCaptureInstance << '\n';
#endif

    setDataLinkType(); //setup the data link type for processing of
    //PacketEvents with PacketHeaders

    //variables used for finding start and end of capture file
    struct pcap_pkthdr *pt_pcapHeader;
    const u_char *pt_snapshot;

    //get the first packet to determine captureStartTime and set the replay
    //postion to the first packet timestamp
    pcapRet = pcap_next_ex(fileCaptureInstance, &pt_pcapHeader, &pt_snapshot);
    if (pcapRet == 1)
    {  //set start time and replay positon
        dataProcessor->captureStartTime.tv_sec = pt_pcapHeader->ts.tv_sec;
        dataProcessor->captureStartTime.tv_usec = pt_pcapHeader->ts.tv_usec;

#ifdef DEBUG_PACKETS_PROCESSED
        packetsRead++;
#endif
    }
    else
    {  switch (pcapRet) //detrmine the error
        {
#ifdef DEBUG_DATA_EXTRACTOR
        case 0: //packets are being read from a live capture, and the
            //timeout expired - this case should never arise when
            //reading a file
            reportError("live capture error, which should not occure when openening the capture file "
                        + file, "libpcap::pcap_next_ex()");
            break;
#endif

        case -1: //an error occurred while reading the packet
            reportError("an error occured while attempting to read the first packet from file "
                        + file, "libpcap::pcap_next_ex()");
            break;
        case -2: //if packets are being read from a ``savefile'', and there are
            //no more packets to read from the savefile
            reportError("there were no packets to be read, capture file " + file
                        + " is presumably empty", "libpcap::pcap_next_ex()");
            break;
        default:
            reportError("unexpected return code from libpcap when attempting to read the first packet from file "
                        + file, "libpcap::pcap_next_ex()");
            break;
        }
        return false;
    }

    //now seek for the end of the file to determine the captureEndTime
    // - for large cap files this will be somewhat inefficient
    bool seekLastPacket = true;
    while (seekLastPacket)
    {  pcapRet = pcap_next_ex(fileCaptureInstance, &pt_pcapHeader, &pt_snapshot);
        if (pcapRet != 1) //if == 1, still more packets
        {  //lets go through to next round of loop
            switch (pcapRet) //detrmine the error
            {  case -2:
                //set the captureEndTime
                dataProcessor->captureEndTime.tv_sec = pt_pcapHeader->ts.tv_sec;
                dataProcessor->captureEndTime.tv_usec = pt_pcapHeader->ts.tv_usec;
                seekLastPacket = false; //found the last packet
                break;

#ifdef DEBUG_DATA_EXTRACTOR
            case 0: //packets are being read from a live capture, and the
                //timeout expired - this case should never arise when
                //reading a file
                reportError("live capture error, which should not occure when openening the capture file "
                            + file, "libpcap::pcap_next_ex()");
                return false; //break out of loop and function after error
                break;
#endif

            case -1: //an error occurred while reading the last packet, assume incomplete capture of last packet
                //set the captureEndTime
                dataProcessor->captureEndTime.tv_sec = pt_pcapHeader->ts.tv_sec;
                dataProcessor->captureEndTime.tv_usec = pt_pcapHeader->ts.tv_usec;
                //provisionally set time values in case there are no more valid packets
                //ignore misread packet and continue looking for last packet
                reportError("an error occured while attempting to search for the last packet in the file, perhaps the file end is corrupt in "
                            + file, "libpcap::pcap_next_ex()");
                break;
            default:
                reportError("unexpected return code from libpcap when attempting to search for the last packet int the file "
                            + file, "libpcap::pcap_next_ex()");
                return false; //break out of loop and function after error
                break;
            }
        }
        else //succesfully read packet and more to come
        {
#ifdef DEBUG_PACKETS_PROCESSED
            packetsRead++;
#endif
        }

    }

    //can now set time values
    dataProcessor->replayPosition.tv_sec = dataProcessor->captureStartTime.tv_sec;
    dataProcessor->replayPosition.tv_usec = dataProcessor->captureStartTime.tv_usec;
    dataProcessor->updateTimevals();
    dataProcessor->updateTimeRange();

    //if the code gets down hear, assume we have succesfully avoided all pitfalls
    //and beging filling the buffer from the file, which requires reopening the
    //capture instance and setting the begining and end times

#ifdef DEBUG_CAPTURE_INSTANCE
    cerr << "DEBUG: closed file capture instance after file scan complete: "
         << fileCaptureInstance << '\n';
#endif

    pcap_close(fileCaptureInstance); //close
    fileCaptureInstance = NULL;

#ifdef DEBUG_PACKETS_PROCESSED
    cerr << "DEBUG: " << packetsRead << " packets scanned\n";
#endif

#ifdef DEBUG_DATA_EXTRACTOR
    QDateTime capSrtTm;
    QDateTime capEndTm;
    TimeUtil::timevalToQDateTime(capSrtTm,
                                 dataProcessor->captureStartTime);
    TimeUtil::timevalToQDateTime(capEndTm,
                                 dataProcessor->captureEndTime);
    cerr << "DEBUG: replay file scan complete:" << endl;
    cerr << "   Timestamp of first packet = "
         << dataProcessor->captureStartTime.tv_sec << " sec, "
         << dataProcessor->captureStartTime.tv_usec << " usec - "
         << capSrtTm.date().toString().toLatin1().data() << ", "
         << capSrtTm.time().toString().toLatin1().data() << ":"
         << capSrtTm.time().msec() << endl;
    cerr << "   Timestamp of last packet = "
         << dataProcessor->captureEndTime.tv_sec << " sec, "
         << dataProcessor->captureEndTime.tv_usec << " usec - "
         << capEndTm.date().toString().toLatin1().data() << ", "
         << capEndTm.time().toString().toLatin1().data() << ":"
         << capEndTm.time().msec() << endl;
    cerr << "   Replay position = "
         << dataProcessor->replayPosition.tv_sec << " sec, "
         << dataProcessor->replayPosition.tv_usec << " usec - "
         << dataProcessor->qdt_replayPosition.date().toString().toLatin1().data() << ", "
         << dataProcessor->qdt_replayPosition.time().toString().toLatin1().data() << ":"
         << dataProcessor->qdt_replayPosition.time().msec() << endl;
    cerr << "DEBUG: reopeing file and initialising for file replay\n";
#endif

    fileCaptureInstance = pcap_open_offline(strReplayFileReference.toLatin1().data(), pcapErrorBuffer);
    //reopen to start from beggining again
    //check for error
    if (fileCaptureInstance == NULL)
    {  //capture file not successfully set
        reportError("failed to open capture file '" + file + "'",
                    "libpcap::pcap_open_offline");
        return false;
    }

#ifdef DEBUG_CAPTURE_INSTANCE
    cerr << "DEBUG: capture instance succesfully opened again for replay: "
         << fileCaptureInstance << '\n';
#endif

    dataProcessor->setMode(REPLAY_FILE); //set replay mode

    //apply filter before proceeding
    if (!applyFilter())
    {  reportError("Failed to apply filter, continued without filter",
                   "DataExtractor::openCaptureFile");
    }

    readCaptureFile(); //will fill buffer ahead up to timewindow end

    //notify the control panel of the beginning and end times (so that its slider
    //can be scaled)

    return true; //success at last :)

}


bool DataProcessor::DataExtractor::reopenCaptureFile()
{

#ifdef DEBUG_DATA_EXTRACTOR
    cerr << "DEBUG: reopening pcap file -----------------------------------------------\n";
#endif

    if (dataProcessor->getMode() == MONITOR_LOCAL)
    {  reportError("failed to re-open capture file '"
                   + strReplayFileReference + "\' due to wrong mode (live monitor mode)",
                   "DataExtractor::reopenCaptureFile()");
        return false;
    }

    dataProcessor->setMode(NOT_READY);

    if (fileCaptureInstance != NULL)
    {  //close the file first
        dataProcessor->packetEventBuffer.clear();
        dataProcessor->updateGLVisWidget();
        //dataProcessor->glVisWidget->update();

#ifdef DEBUG_CAPTURE_INSTANCE
        cerr << "DEBUG: reopening file and previous file capture instance still open\n";
        cerr << "DEBUG: closing file capture instance: " << fileCaptureInstance << '\n';
#endif

        pcap_close(fileCaptureInstance);
        fileCaptureInstance = NULL;
    }

    if (fileCaptureInstance == NULL)
    {  //reopen the file, reapply the filter and seek to the current replay
        //position, refilling the buffer
        fileCaptureInstance = pcap_open_offline(strReplayFileReference.toLatin1().data(),
                                                pcapErrorBuffer);
        //check for error
        if (fileCaptureInstance == NULL)
        {  //capture file not successfully set
            reportError("failed to open capture file '" + strReplayFileReference
                        + "'", "libpcap::pcap_open_offline");
            return false;
        }

#ifdef DEBUG_CAPTURE_INSTANCE
        cerr << "DEBUG: capture instance succesfully reopened for rereading file: "
             << fileCaptureInstance << '\n';
#endif

        dataProcessor->setMode(REPLAY_FILE); //set replay mode

        //apply filter before processing
        if (!applyFilter())
        {  reportError("Failed to apply filter, continued without filter",
                       "DataExtractor::openCaptureFile");
        }
        setDataLinkType(); //setup the data link type for processing of
        //PacketEvents with PacketHeaders
        //seek ahead till we reach the current replay position
        readCaptureFile();

#ifdef DEBUG_DATA_EXTRACTOR
        cerr << "DEBUG: replay file reopened for seeking / time window adjustment\n";
#endif

        return true;
    }
    else //assume an error
    {  reportError("unable to reopen capture file, previous capture instance still open",
                   "DataExtractor::reopenCaptureFile()");
        return false;
    }

}


QString DataProcessor::DataExtractor::getReplayFileName()
{
    return strReplayFileReference;

}


bool DataProcessor::DataExtractor::openInterface(const QString netInterface) {
#ifdef DEBUG_DATA_EXTRACTOR
    cerr << "DEBUG: live interface open --------------------------------------------------------\n";
#endif

    dataProcessor->setMode(NOT_READY);
    if (dataProcessor->getState() == PLAYING) {
        dataProcessor->pause();
    }

    //use existing string value for local interface
    if (netInterface.isEmpty()) {
        return openDefaultInterface();
    } else {
        //set to new value
        strLocalInterface = netInterface;
    }

    if (liveCaptureInstance != NULL) {
#ifdef DEBUG_CAPTURE_INSTANCE
        cerr << "DEBUG: opening live interface and previous live capture instance was still open\n";
        cerr << "DEBUG: closing previous live capture instance"
             << liveCaptureInstance << '\n';
#endif

        pcap_close(liveCaptureInstance);
        liveCaptureInstance = NULL;

        dataProcessor->packetEventBuffer.clear();
        dataProcessor->updateGLVisWidget();
        //dataProcessor->glVisWidget->update();
    }

    if (fileCaptureInstance != NULL) {
#ifdef DEBUG_CAPTURE_INSTANCE
        cerr << "DEBUG: opening live interface and previous file capture instance was still open\n";
        cerr << "DEBUG: closing previous file capture instance: "
             << fileCaptureInstance << '\n';
#endif

        pcap_close(fileCaptureInstance);
        fileCaptureInstance = NULL;

        dataProcessor->packetEventBuffer.clear();
        dataProcessor->updateGLVisWidget();
        //dataProcessor->glVisWidget->update();
    }

    liveCaptureInstance = pcap_open_live(strLocalInterface.toLatin1().data(), packetCaptureLength,
                                         promiscuousMode, readTimeout, pcapErrorBuffer);
    if (liveCaptureInstance == NULL) {
        reportError("error opening network device " + strLocalInterface +
                   " for capture (a lack of user privileges may be the cause)",
                   "libpcap::pcap_open_live");
        return false;
    }
    //else interface opened for capture - check for warning message
    if (checkPcapErrorBuffer()) {
        reportError("libpacp warning when opening network device",
                   "libpcap::pcap_open_live()");
    }

#ifdef DEBUG_CAPTURE_INSTANCE
    cerr << "DEBUG: capture instance succesfully opened for live monitoring: "
         << liveCaptureInstance << '\n';
#endif

    //set capturing mode to non-blocking which is applicable for live capture,
    //but has no effect on replay of capture files
#define NON_BLOCK_MODE 1
    pcapRet = pcap_setnonblock(liveCaptureInstance, NON_BLOCK_MODE, pcapErrorBuffer);
    if (pcapRet == -1) {
        reportError("failed to enable non-blocking live capture mode", "libpcap::pcap_setnonblock()");
        dataProcessor->setMode(NOT_READY);
        return false;
    }

#ifdef DEBUG_DATA_EXTRACTOR
    cerr << "DEBUG: network device " << strLocalInterface.toLatin1().data() << " oppened for capture" << endl;
#endif

    dataProcessor->setMode(MONITOR_LOCAL);
    //setup the data link type for processing of PacketEvents with PacketHeaders
    setDataLinkType();

    //get the local netwrok specification
    lookupNetwork();

    //apply filtering
    applyFilter();

    //begin processing
    dataProcessor->play();

    return true;
}


bool DataProcessor::DataExtractor::openDefaultInterface() {
#define MAX_DEV_NAME_LENGTH 32

    strLocalInterface = QString((const char*)pcap_lookupdev(pcapErrorBuffer));

    if (strLocalInterface.isNull() || strLocalInterface.isEmpty()) {
        reportError("could not lookup default device", "libpcap::pcap_lookupdev");
        dataProcessor->setMode(NOT_READY);
        return false;
    } else {
#ifdef DEBUG_DATA_EXTRACTOR
        cerr << "DEBUG: Default device set: " << strLocalInterface.toLatin1().data() << endl;
#endif
        return openInterface(strLocalInterface);
    }
}


bool DataProcessor::DataExtractor::connectServer(const QString server) {
    //TODO: The idea is to recieve processed information from a server
    return false;
}


bool DataProcessor::DataExtractor::openDumpFile(const QString file)
{
#ifdef DEBUG_RECORD_PACKETS
    cerr << "DEBUG: attempting to open dump file:\n";
#endif

    //check for previous open file
    if (dumpFileDescriptor != NULL)
    {
#ifdef DEBUG_RECORD_PACKETS
        cerr << "   previous dump file = \"" << strRecordFileReference.toLatin1().data()
             << "\" found open, now closing...\n";
#endif

        closeDumpFile();
    }

    //check for valid string and set file reference name
    if (file.isEmpty() || file.isNull())
    {  //check directory

        //suply default name
        if (dataProcessor->getMode() == NOT_READY)
            strRecordFileReference = DEFAULT_DUMP_FILE_NAME;
        else if (dataProcessor->getMode() == REPLAY_FILE)
            strRecordFileReference = "filedump.cap";
        else if (dataProcessor->getMode() == MONITOR_LOCAL)
            strRecordFileReference = "livedump.cap";
    }
    else
        strRecordFileReference = file;

#ifdef DEBUG_RECORD_PACKETS
    cerr << "   new dump file = \"" << strRecordFileReference.toLatin1().data() << "\"\n";
#endif

    //open dump file, according to replay mode
    if (dataProcessor->replayMode == REPLAY_FILE)
        dumpFileDescriptor = pcap_dump_open(fileCaptureInstance,
                                            strRecordFileReference.toLatin1().data());
    else if (dataProcessor->replayMode == MONITOR_LOCAL)
        dumpFileDescriptor = pcap_dump_open(liveCaptureInstance,
                                            strRecordFileReference.toLatin1().data());

    //check that dump file opened correctly
    if (dumpFileDescriptor == NULL) {
        reportError("failed to open dump file: \""
                    + strRecordFileReference + "\"",
                    "libpcap::pcap_dump_open()");
        return false;
    }

    //reset record time
    dataProcessor->lastRecordTime.tv_sec = EARLIEST_REPLAY_POSITION;
    dataProcessor->lastRecordTime.tv_usec = 0;

#ifdef DEBUG_RECORD_PACKETS
    cerr << "   dump file succefully opened\n";
#endif

    return true;

}


void DataProcessor::DataExtractor::recordToDumpFile(bool record) {

#ifdef DEBUG_RECORD_PACKETS
    cerr << "DEBUG: record state changed:\n";
#endif

    //assert that we are not trying to set the same state over
    if (dataProcessor->recordToFile == record) {
        QString strRecordState;
        if (dataProcessor->recordToFile) {
            strRecordState = "on";
        }
        else {
            strRecordState = "off";
        }
        reportError("record state already " + strRecordState,
                    "DataExtractor::recordToFile()");
        return;
    }

    //check to see if we're beginnig to record
    if (record) {
        //start recording
        //check if dump file already open, and if not, generate auto name per
        //record session - a record session is a press and consequent depress
        //of the button
        if (dumpFileDescriptor == NULL) {
            //assume session mode
            recMode = SESSION;
        }

        if (recMode == SESSION) {
            //create filename bassed on capture mode and file start time
            QString dumpFileName;
            if (dataProcessor->getMode() == REPLAY_FILE) {
                QString replayFileName = dataProcessor->getReplayFileName();
                dumpFileName = getPcapsDir() + QString("/")
                        + QString(getReplaySubdir()) + QString("/")
                        + replayFileName;
                QDir dir;
                //need to create sub dir
                if (!dir.exists(dumpFileName)) {
                    if(!dir.mkdir(dumpFileName)) {
                        reportError("could not create subdirectory for record session file",
                                   "DataExtractor::recordToFile()");
                        return;
                    }
                }
                dumpFileName
                        += QString("/")
                        + dataProcessor->qdt_twEnd.toString("yyyyMMdd-hhmmss");
            }
            else if (dataProcessor->getMode() == MONITOR_LOCAL) {
                dumpFileName = QString(getPcapsDir()) + QString("/")
                        + QString(getLiveSubdir()) + QString("/")
                        + dataProcessor->qdt_replayPosition.toString("yyyyMMdd-hhmmss");
                //this must be changed to the time window end if the buffer
                //is dumped to file (TODO)
            }
            //only add extention once closing file
            //now open session file
            if(!openDumpFile(dumpFileName)) {
                emit dataProcessor->setRecordButton(false);
                return;
                //openDumpFile() will report the error
            }
        }

        //set recording flag
        dataProcessor->recordToFile = true;

#ifdef DEBUG_RECORD_PACKETS
        cerr << "   started recording packets to dump file \"";
        cerr << strRecordFileReference.toLatin1().data() << "\"\n";
#endif

        //now process packets
        if (dataProcessor->getMode() == REPLAY_FILE) {

            //reprocess file to record all packets already in time window
            reopenCaptureFile(); //we want to copy from the original file
            //the packet proccessing function will dump packets during reread
            //coping data in current buffer
        }
        else if (dataProcessor->getMode() == MONITOR_LOCAL) {

            //dump current buffer contents
            deque<PacketEvent>::iterator itr;
            for (itr = dataProcessor->packetEventBuffer.begin();
                 itr != dataProcessor->packetEventBuffer.end();
                 itr++) {
                if (itr->graphicElement != NULL) {
                    //copy event data in pcap pkyhdr struct
                    struct pcap_pkthdr pktHdr;
                    pktHdr.ts.tv_sec = itr->timeStamp.tv_sec;
                    pktHdr.ts.tv_usec = itr->timeStamp.tv_usec;
                    pktHdr.caplen = itr->captureLength;
                    pktHdr.len = itr->packetLength;
                    //dump raw data, but first revert byte order changes previously
                    //made when parsing the data the first time (host to network
                    //byte order issue)
                    PacketHeaders::deParsePacket(itr->headers);
                    //now save to file
                    pcap_dump((u_char*)statDataProcessor->dataExtractor.dumpFileDescriptor, &pktHdr, itr->rawPacket);
                }
            }
        }
    }
    else {
        //stop recording
        dataProcessor->recordToFile = false;

#ifdef DEBUG_RECORD_PACKETS
        cerr << "   stopped recording packets to dump file \"";
        cerr << strRecordFileReference.toLatin1().data() << "\"\n";
#endif

        //if in SESSION mode, close and rename file
        if (recMode == SESSION) {
            closeDumpFile();
            //setup file references to filename and path
            QDir fileRef = QDir(strRecordFileReference);
            QString fileName = fileRef.dirName(); //get file name
            QString filePath = QString(fileRef.path());
            filePath = filePath.remove(fileName); //get dir on its own
            filePath = strRecordFileReference.remove(fileName);
            //navigate into dir and rename file
            if (!fileRef.exists()) {
                QString newFileName = fileName + QString(" - ")
                        + dataProcessor->qdt_replayPosition.toString("yyyyMMdd-hhmmss")
                        + QString(".cap");
                QDir navDir = QDir(dataProcessor->strAppDir);
                if (navDir.cd(filePath)) {
                    //rename file
                    if (!navDir.rename(fileName, newFileName)) {
                        reportError("could not rename record session file",
                                   "DataExtractor::recordToFile()");
                    }
                    else {
#ifdef DEBUG_RECORD_PACKETS
                        cerr << "   recording session dump file closed and renamed to\"";
                        cerr << newFileName.toLatin1().data() << "\"\n";
#endif
                    }
                }
                else {
                    reportError("could not change directory in order to rename record session file",
                               "DataExtractor::recordToFile()");
                }
            }
            else {
                reportError("could not rename record session file",
                           "DataExtractor::recordToFile()");
            }
        }
        //if in CONTINUOUS mode, leave file open untill recording is reiniated
        //or file manually closed
    }
}


void DataProcessor::DataExtractor::closeDumpFile()
{

#ifdef DEBUG_RECORD_PACKETS
    cerr << "DEBUG: attempting to close dump file:\n";
#endif

    //check to ensure file is open
    if (dumpFileDescriptor == NULL)
    {  reportError("failed to close dump file since no file was open",
                   "DataExtractor::closeDumpFile()");
        return;
    }

    //flush file
    if (pcap_dump_flush(dumpFileDescriptor) == -1)
    {  reportError("failed to flush dump file before closing",
                   "DataExtractor::closeDumpFile()");
    }

    //check to see if still in record mode
    if (dataProcessor->recordToFile)
    {  recordToDumpFile(false);
        //uidate GUI
        emit dataProcessor->setRecordButton(false);
    }

    //now close file
    pcap_dump_close(dumpFileDescriptor);
    dumpFileDescriptor = NULL;

#ifdef DEBUG_RECORD_PACKETS
    cerr << "   dump file \"" << strRecordFileReference.toLatin1().data() << "\" closed\n";
#endif

}


bool DataProcessor::DataExtractor::setFilterExpr(const QString filter)
{
    if (filter.isNull() || filter.isEmpty())
    {   bpfFilterExpr = "";
    }
    else
    {  bpfFilterExpr = " and (" + filter + ')';
    }

    if (liveCaptureInstance != NULL || fileCaptureInstance != NULL)
    {  return applyFilter(); //apply the filter to the current capture instance
    }
    else
    {  return false;
    }

}


bool DataProcessor::DataExtractor::setImplicitFilter(const QString impFilter)
{
    if (impFilter.isNull())
    {   return false;
    }
    else
    {  if (!impFilter.isEmpty())
        {  implicit_bpf_FilterExpr = '(' + QString(IMPLICIT_BPF_FILTER_EXP) + " and ("
                    + impFilter + "))";
        }
        else
        {  implicit_bpf_FilterExpr = QString(IMPLICIT_BPF_FILTER_EXP);
        }
    }

    if (liveCaptureInstance != NULL || fileCaptureInstance != NULL)
    {  return applyFilter(); //apply the filter to the current capture instance
    }
    else
    {  return false;
    }

}


bool DataProcessor::DataExtractor::applyFilter() {
#define MAX_EXPR_LENGTH 1024

#ifdef DEBUG_FILTER
    cerr << "DEBUG: Attempting to apply filter:\n";
    cerr << "   implicit filter expression = \"" << implicit_bpf_FilterExpr
         << "\"\n";
    cerr << "   user filter expression = \"" << bpfFilterExpr << "\"\n";
    cerr << "   current mode = ";
    if (dataProcessor->getMode() == REPLAY_FILE)
        cerr << "REPLAY_FILE\n";
    else if (dataProcessor->getMode() == MONITOR_LOCAL)
        cerr << "MONITOR_LOCAL\n";
    else if (dataProcessor->getMode() == NOT_READY)
        cerr << "NOT_READY\n";
#endif

    //an empty string for filter is acceptable, since implicit filter is in place.
    char filterExpr[MAX_EXPR_LENGTH];

    //check that the string will be within bounds of the string buffer
    if ((implicit_bpf_FilterExpr.length() + bpfFilterExpr.length()) < MAX_EXPR_LENGTH) {
        strcpy(filterExpr, (implicit_bpf_FilterExpr + bpfFilterExpr).toLatin1().data());
        //QString will cast to const char*
    }
    else
    {  reportError("filter expression and implicit filter expression too large (>1024 chars), filter not set",
                   "DataExtractor::setFilter");
        return false;
    }

    if (bpfFilterExpr.isNull()) {
        reportError("filter expression NULL, assumed empty expression",
                   "DataExtractor::setFilter");
        bpfFilterExpr = "";
        return applyFilter(); //now try again
    }

    if (netMask == 0) {
        if (getShowHomeNetworkNotSetError()) {
            reportError("WARNING: home network not set. Use the plotter settings dialog to set the network address and mask.",
                   "DataExtractor::setFilter");
            //this will not prevent the filter from working in most cases except
            //braodcast packets - according to man pcap
        }
    }

    //pcap 0.8.3 and before has a bug with port range and optimized filter
    //get version string by converting it to a number
    QString pcapVer = pcap_lib_version();

#ifdef DEBUG_FILTER
    cerr << "   libpcap version = " << pcapVer << "\n";
#endif

    int ver = 0; //to compare if version is recent enough
    int verPos = 0; //index in string where version number begins
    verPos = pcapVer.lastIndexOf(' '); //version at end of string
    pcapVer.remove(0,verPos); //remove text before version number
    pcapVer.remove('.'); //remove dots
    ver = pcapVer.toInt();

    //check version for greater than 0.8.3
    if (ver > 83)  {
        //we can optimise
        if (dataProcessor->getMode() == REPLAY_FILE) {
            pcapRet = pcap_compile(fileCaptureInstance, &bpfFilterProg, filterExpr,
                                   OPTIMISE_BPF_FILTER, netMask);
        }
        else if (dataProcessor->getMode() == MONITOR_LOCAL) {
            pcapRet = pcap_compile(liveCaptureInstance, &bpfFilterProg, filterExpr,
                                   OPTIMISE_BPF_FILTER, netMask);
        }

#ifdef DEBUG_FILTER
        cerr << "   libpcap version > 0.8.3, filter IS optimised\n";
#endif
    }
    else //cannot optimise due to libpcap filer bug
    {  if (dataProcessor->getMode() == REPLAY_FILE)
            pcapRet = pcap_compile(fileCaptureInstance, &bpfFilterProg, filterExpr,
                                   DONT_OPTIMISE_BPF_FILTER, netMask);
        else if (dataProcessor->getMode() == MONITOR_LOCAL)
            pcapRet = pcap_compile(liveCaptureInstance, &bpfFilterProg, filterExpr,
                                   DONT_OPTIMISE_BPF_FILTER, netMask);

#ifdef DEBUG_FILTER
        cerr << "   libpcap version <= 0.8.3, filter NOT optimised\n";
#endif
    }

    if (pcapRet == -1) {
        if (dataProcessor->getMode() == REPLAY_FILE) {
            strcpy(pcapErrorBuffer, pcap_geterr(fileCaptureInstance)); //copy error into
        }
        //error buffer
        else if (dataProcessor->getMode() == MONITOR_LOCAL) {
            strcpy(pcapErrorBuffer, pcap_geterr(liveCaptureInstance)); //copy error into
        }
        //error buffer
        reportError("could not compile filter expression",
                    "libpacp::pcap_compile");
        return false;
    }

#ifdef DEBUG_FILTER
    cerr << "   filter expression successfuly compiled\n";
#endif

    //set filter
    if (dataProcessor->getMode() == REPLAY_FILE) {
        pcap_setfilter(fileCaptureInstance, &bpfFilterProg);
        if (pcapRet == -1) {
            strcpy(pcapErrorBuffer, pcap_geterr(fileCaptureInstance));
            //copy error into error buffer
            reportError("could not set filter for file '" + strReplayFileReference
                        + "'", "libpacp::pcap_setfilter");
            return false;
        }
        else {
#ifdef DEBUG_FILTER
            cerr << "   filter expression successfuly set for file replay\n";
#endif
        }
    }
    if (dataProcessor->getMode() == MONITOR_LOCAL) {
        pcap_setfilter(liveCaptureInstance, &bpfFilterProg);
        if (pcapRet == -1) {
            strcpy(pcapErrorBuffer, pcap_geterr(liveCaptureInstance));
            //copy error into error buffer
            reportError("could not set filter for interface '" + strLocalInterface
                        + "'", "libpacp::pcap_setfilter");
            return false;
        }
        else {
#ifdef DEBUG_FILTER
            cerr << "   filter expression successfuly set for live monitoring\n";
#endif
        }
    }

#ifdef DEBUG_DATA_EXTRACTOR
    if (pcapRet != -1)
        cerr << "DEBUG: filter compiled and set to: '" << filterExpr
             << "' (including implicit filter), with net mask of "
             << QString::number(netMask).toLatin1().data() << endl;
#endif

    return true;
}


QString DataProcessor::DataExtractor::getImplicitFilter() {
    return implicit_bpf_FilterExpr;
}


bool DataProcessor::DataExtractor::checkPcapErrorBuffer() {
    if (pcapErrorBuffer != NULL) {
        if (pcapErrorBuffer[0] == '\0') {
            return false; //there is no error message present
        }
        else {
            return true; //there is an error message present
        }
    }
    else {
        return false; //there is no error message present
    }
}

void DataProcessor::DataExtractor::resetPcapErrorBuffer() {
    pcapErrorBuffer[0] = '\0'; //reset to empty string
}

QString DataProcessor::DataExtractor::copyPcapError() {
    return QString((const char*)pcapErrorBuffer); //forces a deep copy of the
    //string rather than a copy by reference
}


void DataProcessor::DataExtractor::run()
{
    //depending on the mode run appropriate data extraction operation
    switch (dataProcessor->replayMode)
    {  case REPLAY_FILE:
        readCaptureFile();
        break;
    case MONITOR_LOCAL:
        monitorLocalHost();
        break;
    case MONITOR_REMOTE:
        monitorRemoteServer();
        break;
        //in any other case we dont need to do any processing
    }

    //remove data past the time window from the end of the buffer
    if (!dataProcessor->packetEventBuffer.empty())
    {
        deque<PacketEvent>::iterator itr;
        itr = dataProcessor->packetEventBuffer.end();
        //must decriment once befire use
        for (itr--; (itr != dataProcessor->packetEventBuffer.begin() &&
                     TimeUtil::timevalGreaterThan(dataProcessor->timeWindowEnd, itr->timeStamp));
             itr--)
        {  dataProcessor->packetEventBuffer.pop_back(); //remove from back of queue

#ifdef DEBUG_DATA_RENDER
            cerr << "DEBUG: removed element from back of queue\n";
#endif
        }
    }
}


//DataProcessor ----------------------------------------------------------------

//Constructor and Destructor ------------------------------

DataProcessor::DataProcessor() {

    //link objects
    dataExtractor.setDataProcLink(this);

    //init state variables
    replayMode = NOT_READY;
    replayState = PAUSED;
    transDecay = false;
    transDecayNextRender = false;
    transDecayFrac = 0.0;
    newPointBulge = false;
    recordToFile = false;

    //ensure default application dirs are present, or else create them
    strAppDir = QDir::currentPath();
    if (!checkDefaultDirs()) {
        reportError("Unable to create default application directory", "DataProcessor()");
    }

    //initialization to 'zero' states, representing 02:00 01 Jan 1970
    currentTime.tv_sec = EARLIEST_REPLAY_POSITION;
    currentTime.tv_usec = 0;
    replayPosition.tv_sec = EARLIEST_REPLAY_POSITION;  //Jan 1980
    replayPosition.tv_usec = 0;
    TimeUtil::timevalToQDateTime(qdt_replayPosition, replayPosition);
    captureStartTime.tv_sec = EARLIEST_REPLAY_POSITION;
    captureStartTime.tv_usec = 0;
    captureEndTime.tv_sec = MAX_INT;
    captureEndTime.tv_usec = MAX_INT;
    lastRecordTime.tv_sec = EARLIEST_REPLAY_POSITION;
    lastRecordTime.tv_usec = 0;
    bulgeTime.tv_sec = 0;
    bulgeTime.tv_usec = NEW_POINT_BULGE_USEC;
    stopBulgeTime.tv_sec = 0;
    stopBulgeTime.tv_usec = NEW_POINT_BULGE_USEC;

    //init replay timeing defaults
    updateRate = (int)((1.0 / DEFAULT_UPDATE_RATE) * 1000); //result in msec
    timeFactor = DEFAULT_REPLAY_RATE;

#ifdef DEBUG_DATA_PROCESSOR
    cerr << "BEBUG: DataProcessor INIT ------------------------------------------------------\n";
    cerr << "DEBUG: update rate init to default : " << updateRate
         << " msec per update\n";
#endif

    updateTimeIncrimental(updateRate);
    TimeUtil::doubleToTimeval(timeWindow, DEFAULT_TIME_WINDOW);
    TimeUtil::doubleToTimeval(bufferAhead, DEFAULT_BUFFER_UNDERUN_PROTECTION);
    updateTimevals();
    updateTimeRange();

    //implicit filter strings
    dstNetFilter = "";
    srcNetFilter = "";
    portFilter = "";

#ifdef DEBUG_DATA_PROCESSOR
    cerr << "DEBUG: time window set to : " << timeWindow.tv_sec
         << " secs, " << timeWindow.tv_usec << " microsecs\n";
    cerr << "DEBUG: replay rate init to default : " << timeFactor << "x\n";
    cerr << "DEBUG: replay position init: "
         << qdt_replayPosition.date().toString().toLatin1().data() << ", "
         << qdt_replayPosition.time().toString().toLatin1().data() << ":"
         << qdt_replayPosition.time().msec() << endl;
    cerr << "DEBUG: time window end init: " << qdt_twEnd.date().toString().toLatin1().data()
         << ", " << qdt_twEnd.time().toString().toLatin1().data() << ":"
         << qdt_twEnd.time().msec() << endl;
#endif

    //list of interfaces
    strAllLocalInterfaces = QStringList();

    //default plotting setting
    //set ranges for 4 byte IP address, 4 byte IP address, 2 byte port value
    Plotter::setRanges(0, (unsigned int)MAX_U_INT32_VAL, 0, MAX_U_INT16_VAL,
                       0, (unsigned int)MAX_U_INT32_VAL, 0, MAX_U_INT16_VAL,
                       DEFAULT_DRAWING_FIELD_SIZE);

    //processor update rate timming
    processTimer = new QTimer(this);
    connect(processTimer, SIGNAL(timeout()), this, SLOT(update()));
    processTimer->start(updateRate);

    //status message report timming
    statusTimer = new QTimer(this);
    connect(statusTimer, SIGNAL(timeout()), this, SLOT(updateStatus()));
    statusTimer->start(1000); //update every second

#ifdef DEBUG_DATA_PROCESSOR
    cerr << "BEBUG: DataProcessor INIT complete ---------------------------------------------\n";
#endif

}


DataProcessor::~DataProcessor()
{
    //delete midnightJan1970;
    delete processTimer;
    delete statusTimer;

}


//DataProcessor private functions -------------------------


void DataProcessor::updateTimeIncrimental(int tmLapse)
{
    TimeUtil::doubleToTimeval(updateTimeInc, (timeFactor / (1000.0 / tmLapse)));
    //set the time value incriment per update as:
    //updateTimeInc = replay rate / updates per sec
    //updates per sec = 1000 / update period in msec

#ifdef DEBUG_DATA_PROCESSOR
    cerr << "DEBUG: update incriment for replay time set to: "
         << updateTimeInc.tv_sec << " seconds, and "
         << updateTimeInc.tv_usec << " microsecs\n";
#endif

    //if (replayMode == REPLAY_FILE)
    transDecayFrac = TimeUtil::timevalToDouble(updateTimeInc)*timeFactor
            /TimeUtil::timevalToDouble(timeWindow);

}


void DataProcessor::updateTimevals()
{
    TimeUtil::addTimevals(bufferPosition, bufferAhead, replayPosition);
    //bufferPosition = replayPosition + bufferAhead
    TimeUtil::subTimevals(timeWindowEnd, timeWindow, replayPosition);
    //timeWindowEnd = replayPosition + timeWindow

    //for gui output
    TimeUtil::timevalToQDateTime(qdt_replayPosition, replayPosition);
    TimeUtil::timevalToQDateTime(qdt_twEnd, timeWindowEnd);
    //update the gui with the replay position and time window ending
    //position

    if (newPointBulge)
    {  TimeUtil::subTimevals(stopBulgeTime, bulgeTime, replayPosition);

#ifdef DEBUG_NEW_POINT_BULGE
        QDateTime sbt;
        TimeUtil::timevalToQDateTime(sbt, stopBulgeTime);
        cerr << "DEBUG: New point bulge (time value update):\n";
        cerr << "   replay time       =  "
             << qdt_replayPosition.toString("yyyy/MM/dd-hh:mm:ss:zzz")
             << '\n';
        cerr << "   bulge period      =  "
             << TimeUtil::realativeTimevalToQString(bulgeTime) << '\n';
        cerr << "   stop bulge time   =  "
             << sbt.toString("yyyy/MM/dd-hh:mm:ss:zzz") << '\n';
#endif
    }

    emit updateReplayTimeDisplay(qdt_replayPosition, qdt_twEnd);

}


void DataProcessor::updateTimeRange()
{
    //To notify the control panel of the start and end times
    QDateTime start, end;
    TimeUtil::timevalToQDateTime(start, captureStartTime);
    TimeUtil::timevalToQDateTime(end, captureEndTime);
    emit setTimeRange(start, end);

}


bool DataProcessor::updateImplicitFilter()
{
    QString impFilter = "";
    //check for implicit filter sub componets and build filter expression
    // - care must be taken to get brackets right, and not to have empty
    //   bracket sets, else filter will not compile
    //*
    //check what nets/ranges have been set
    bool dstNetSet = !(dstNetFilter.isEmpty() || dstNetFilter.isNull());
    bool srcNetSet = !(srcNetFilter.isEmpty() || srcNetFilter.isNull());
    bool portRangeSet = !(portFilter.isEmpty() || portFilter.isNull());

    //check if both the src and dst networks are set, or which one, or none
    if (dstNetSet && srcNetSet)
    {  impFilter = '(' + dstNetFilter + " and " + srcNetFilter + ')';
    }
    else if (dstNetSet)
    {  impFilter = '(' + dstNetFilter + ')';
    }
    else if (srcNetSet)
    {  impFilter = '(' + srcNetFilter + ')';
    }
    //otherweise niether was set

    //check if the port range is specified
    if (portRangeSet)
    {  if (impFilter.isEmpty())
            impFilter = '(' + portFilter + ')';
        else
            impFilter += " and (" + portFilter + ')';
    }
    //*/

    /*//old code

   if (!(dstNetFilter.isEmpty() || dstNetFilter.isNull()))
   {  impFilter = '(' + dstNetFilter + ')';
   }
   if (!(srcNetFilter.isEmpty() || srcNetFilter.isNull()))
   {  if (impFilter.isEmpty())
         impFilter = '(' + srcNetFilter + ')';
      else
         impFilter += " and (" + srcNetFilter + ')';
   }
   if (!(portFilter.isEmpty() || portFilter.isNull()))
   {  if (impFilter.isEmpty())
         impFilter = '(' + portFilter + ')'; //or icmp is necessary,
               //otherwise icmp traffic will be eliminated
      else
         impFilter += " and (" + portFilter + ')';
   }

//old code*/

    //update the data extractor
    return dataExtractor.setImplicitFilter(impFilter);

}


bool DataProcessor::checkDefaultDirs() {
    QDir dir = QDir();
    QString strDir = QString("");

    //main record dir
    if(!dir.exists(getRecordDir())) {
        if (!dir.mkdir(getRecordDir())) {
            return false;
        }
    }

    //sub dirs
    if(!dir.exists(getPcapsDir())) {
        if (!dir.mkdir(getPcapsDir())) {
            return false;
        }
    }

    strDir = QString(getPcapsDir());
    strDir.append('/');
    strDir.append(getLiveSubdir());

    if (!dir.exists(strDir)) {
        if (!dir.mkdir(strDir)) {
            return false;
        }
    }

    strDir = QString(getPcapsDir());
    strDir.append('/');
    strDir.append(getReplaySubdir());
    if (!dir.exists(strDir)) {
        if (!dir.mkdir(strDir)) {
            return false;
        }
    }

    if (!dir.exists(getFramesDir())) {
        if (!dir.mkdir(getFramesDir())) {
            return false;
        }
    }

    strDir = QString(getFramesDir());
    strDir.append('/');
    strDir.append(getLiveSubdir());

    if (!dir.exists(strDir)) {
        if (!dir.mkdir(strDir)) {
            return false;
        }
    }

    strDir = QString(getFramesDir());
    strDir.append('/');
    strDir.append(getReplaySubdir());

    if (!dir.exists(strDir)) {
        if (!dir.mkdir(strDir)) {
            return false;
        }
    }

    if (!dir.exists(getSnapshotsDir())) {
        if (!dir.mkdir(getSnapshotsDir())) {
            return false;
        }
    }

    strDir = QString(getSnapshotsDir());
    strDir.append('/');
    strDir.append(getLiveSubdir());

    if (!dir.exists(strDir)) {
        if (!dir.mkdir(strDir)) {
            return false;
        }
    }

    strDir = QString(getSnapshotsDir());
    strDir.append('/');
    strDir.append(getReplaySubdir());

    if (!dir.exists(strDir)) {
        if (!dir.mkdir(strDir)) {
            return false;
        }
    }

    return true;
}


//DataProcessor public functions --------------------------

void DataProcessor::init()
{
#ifdef DEBUG_DATA_PROCESSOR
    cerr << "BEBUG: Setting DataProcessor defaults ---------------------------------------------\n";
#endif

    //get list of local interfaces - if not root this will fail
    dataExtractor.findAllDevices(strAllLocalInterfaces);

    //init plotting labels and dialog
    emit updateSourceNetworkDisplay(0, 0, 0, 0, 0,
                                    "0.0.0.0 - 255.255.255.255 (0.0.0.0)");
    emit updateHomeNetworkDisplay(0, 0, 0, 0, 0,
                                  "0.0.0.0 - 255.255.255.255 (0.0.0.0)");
    emit setXAxisLabels(PacketHeaders::ipAdrToDecDotStr(0),
                        PacketHeaders::ipAdrToDecDotStr(MAX_U_INT32_VAL));
    emit setZAxisLabels(PacketHeaders::ipAdrToDecDotStr(0),
                        PacketHeaders::ipAdrToDecDotStr(MAX_U_INT32_VAL));
    emit setYAxisLabels(QString::number(0), QString::number(65535));

    //defualt mode is live monitoring on default network interface
    //set filter
    dataExtractor.setFilterExpr(""); //default to implicit filter
    //update gui
    emit updateReplayRateDisplay(timeFactor);
    emit setDateTimeReference(&qdt_replayPosition);
    emit updateReplayTimeDisplay(qdt_replayPosition, qdt_twEnd);
    double timeWin = TimeUtil::timevalToDouble(timeWindow);
    emit updateTimeWindowDisplay(timeWin);
#ifdef DEBUG_DATA_PROCESSOR
    cerr << "BEBUG: DataProcessor defaults set ---------------------------------------------\n";
#endif

}


DataProcessor *DataProcessor::getDataProcessorPtr()
{
    return this;

}


/*
void DataProcessor::addPacketEvent(const PacketEvent &pe)
{
   //in future, if DataExtractor were threaded, we would need to control access
   //to the packetEventBuffer

   #ifdef DEBUG_DATA_PROCESSOR
      cerr << "DEBUG: adding packet to buffer" << endl;
   #endif

   packetEventBuffer.push_front(pe); //I assume this copies the packet event
     //rather than just the reference

   #ifdef DEBUG_DATA_PROCESSOR
      cerr << "DEBUG: added packet to buffer" << endl;
   #endif

}
*/


//DataProcessor communication slots -----------------------


void DataProcessor::setMode(int mode)
{
    //check for valid mode
    switch (mode)
    {  case NOT_READY:
        replayMode = NOT_READY;
        pause();

#ifdef DEBUG_DATA_PROCESSOR
        cerr << "DEBUG: NOT_READY mode set\n";
#endif

        break;
    case MONITOR_LOCAL:
        replayMode = MONITOR_LOCAL;
#ifdef DEBUG_DATA_PROCESSOR
        cerr << "DEBUG: MONITOR_LOCAL mode set\n";
#endif
        break;
    case MONITOR_REMOTE:
        replayMode = MONITOR_REMOTE;

#ifdef DEBUG_DATA_PROCESSOR
        cerr << "DEBUG: MONITOR_REMOTE mode set\n";
#endif

        break;
    case REPLAY_FILE:
        replayMode = REPLAY_FILE;

#ifdef DEBUG_DATA_PROCESSOR
        cerr << "DEBUG: REPLAY_FILE mode set\n";
#endif

        break;
    default:
        replayMode = NOT_READY;
        pause();

        //incorrect value passed
        reportError("invalid mode selected, NOT_READY set, and display paused",
                    "DataProcessor::setMode");
        break;
    }

}


void DataProcessor::selectReplayFile(const QString file)
{
    if (file.isNull())
    {  reportError("filename null, cannot set replay file", "DataProcessor::selectRepalyFile");
        return;
    }

    if (file == "")
    {  reportError("filename empty, cannot set replay file", "DataProcessor::selectRepalyFile");
        return;
    }

    if(dataExtractor.openCaptureFile(file))
    {
#ifdef DEBUG_DATA_EXTRACTOR
        cerr << "opened \"" << file.toLatin1().data() << "\" for replay"
             << endl;
#endif

        setMode(REPLAY_FILE);
    }
    else
    {  //file failed to open
        reportError("unable to open the selelected file \"" + file + '\"',
                    "DataProcessor::selectRepalyFile");
    }

}


void DataProcessor::selectNetworkInterface(const QString netInterface) {
    if (replayMode != MONITOR_LOCAL) {
        if (dataExtractor.openInterface(netInterface)) {
            //try guess home network
            guessHomeNetwork();
            unsigned int a, m; //address, mask
            dataExtractor.getHomeNetwork(a, m);
            setHomeNetwork(a, m);
        }
        //openInterface() and guessHomeNetwork() will report errors
    }
    //else already monitoring local interface
}


void DataProcessor::selectRemoteServer(const QString server)
{
}


void DataProcessor::setFilter(const QString filterExpression)
{
    if (!dataExtractor.setFilterExpr(filterExpression))
    {  reportError("problem with setting filer", "DataProcessor::setFilter()");
    }
    else
    {  //now reopen the the capture instance
        if (replayMode == REPLAY_FILE)
        {  dataExtractor.reopenCaptureFile();
        }
        if (replayMode == MONITOR_LOCAL)
        {  dataExtractor.openInterface("");
        }
        //now update the display list if in static render mode
        if (replayState != PLAYING)
            generatePointDispList();


        //emit updateGLVisWidget();
        //glVisWidget->update();

    }

}


void DataProcessor::setReplayPosition(const struct timeval newReplayPos)
{
    struct timeval proposedRepPos;
    proposedRepPos.tv_sec = newReplayPos.tv_sec;
    proposedRepPos.tv_usec = newReplayPos.tv_usec;
    QDateTime qdt_propRepPos; //to hold QDateTime version

    //get current replay state
    if (replayMode == MONITOR_LOCAL)
        return; //should not change replay postion
    //get previous replay state
    int previousState = replayState;
    if (previousState == PLAYING)
        pause(); //pasue for processing

    //check for invalid values, which we'd expect the caller to look out for
    if (TimeUtil::timevalGreaterThan(captureStartTime, proposedRepPos))
    {  //if proposed time before start time, set to start time
        TimeUtil::timevalToQDateTime(qdt_propRepPos, proposedRepPos);
        /* avoid spamming gui, due to inaccurate slider bar
      reportError("chosen replay time " + qdt_propRepPos.toString()
            + " invalid and before capture start time, set replay time to capture start time",
            "DataProcessor::setReplayPosition()");
      */
        proposedRepPos = captureStartTime;
    }
    else if (TimeUtil::timevalGreaterThan(proposedRepPos, captureEndTime))
    {  //if proposed time after end time, set to end time
        QDateTime qdt_endPos;
        TimeUtil::timevalToQDateTime(qdt_propRepPos, proposedRepPos);
        TimeUtil::timevalToQDateTime(qdt_endPos, captureEndTime);
        /* avoid spamming gui, due to inaccurate slider bar
      reportError("chosen replay time " + qdt_propRepPos.toString()
            + "invalid and past capture end time, '" + qdt_endPos.toString()
            + "', replay postition set to capture end time",
            "DataProcessor::setReplayPosition()");
      */
        proposedRepPos = captureEndTime;
        replayState = REPLAY_AT_END;
        pause();
    }

    //at this point replay position is set to valid range
    //if the replay position is behind, the we need to reopen the file and
    //seek to the position
    if (TimeUtil::timevalGreaterThan(replayPosition, proposedRepPos))
    {  //if the previous replay position was beyond the proposed one
        replayPosition = proposedRepPos;
        updateTimevals(); //will refresh timevals in gui display
        if (replayMode == REPLAY_FILE)
        {  dataExtractor.reopenCaptureFile();
        }
    }
    else
    {  //we can just seek ahead, as the dataExtractor readCaptureFile will
        //do so automatically
        replayPosition = proposedRepPos;
        updateTimevals(); //will refresh timevals in gui display
        dataExtractor.run();

        //emit updateGLVisWidget();
        //glVisWidget->update();

    }

#ifdef DEBUG_DATA_PROCESSOR
    cerr << "DEBUG: replay position set to: " << qdt_replayPosition.toString().toLatin1().data()
         << endl;
#endif

    //to be safe, regenerate the static display list
    generatePointDispList();

    //set replay state according to previous play value
    if (previousState == PLAYING)
        play();

}


void DataProcessor::setReplayPosition(const QDateTime newReplayPos)
{
    struct timeval proposedRepPos;
    TimeUtil::qDateTimeToTimeval(proposedRepPos, newReplayPos);

    setReplayPosition(proposedRepPos);

}


void DataProcessor::play()
{
    if (replayState != PLAYING && replayMode != NOT_READY)
    {  //make shure we are in a valid time range
        if (replayMode == MONITOR_LOCAL)
        {  replayState = PLAYING;
        }
        if (replayMode == REPLAY_FILE)
        {  if (TimeUtil::timevalGreaterThan(captureEndTime, replayPosition))
            {  replayState = PLAYING;
                emit playing();
            }
            else
            {  reportError("cannot play, replay position cannot go beyond the capture end time",
                           "DataProcessor::play()");
            }
        }
    }
    else
    {  if (replayMode == NOT_READY)
        {  reportError("cannot play, not in ready mode", "DataProcessor::play()");
            pause();
        }

        if (replayState == REPLAY_AT_END)
        {  reportError("cannot play, replay file at end", "DataProcessor::play()");
            pause();
        }

#ifdef DEBUG_DATA_PROCESSOR
        if (replayState == PLAYING)
            cerr << "DEBUG: already playing" << endl;
#endif

    }
}


void DataProcessor::pause()
{

    if (replayState != PAUSED)
    {  replayState = PAUSED;
        emit paused();
        //need to update the static display list
        generatePointDispList();

    }
    else
    {
#ifdef DEBUG_DATA_PROCESSOR
        if (replayState == PAUSED)
            cerr << "DEBUG: already paused" << endl;
#endif
    }

}


void DataProcessor::togglePlayPause()
{
    //toggle betweem replay state
    switch (replayState)
    {  case PLAYING:
        pause();
        break;
    case PAUSED:
        play();
        break;
    }
    //else not ready

}


void DataProcessor::record(bool rec) {
    dataExtractor.recordToDumpFile(rec);
}


void DataProcessor::setReplayRate(double rate)
{
    if (replayMode != MONITOR_LOCAL)
    {
        if (rate > MAX_REPLAY_RATE)
        {  //set to max replay rate
            timeFactor = MAX_REPLAY_RATE;
            reportError("selected replay rate above bounds of " +
                        QString::number(MAX_REPLAY_RATE) + " seconds, set to "
                        + QString::number(MAX_REPLAY_RATE),
                        "DataProcessor::setReplayeRate");
        }
        else if (rate < MIN_REPLAY_RATE)
        {  timeFactor = MIN_REPLAY_RATE;
            reportError("selected replay rate below bounds of " +
                        QString::number(MIN_REPLAY_RATE) + " seconds, set to "
                        + QString::number(MIN_REPLAY_RATE),
                        "DataProcessor::setReplayeRate");
        }
        else
        {  timeFactor = rate;
        }
    }
    else //should play at 1.0 for live playback
    {  timeFactor = 1.0;
    }

    updateTimeIncrimental(updateRate); //useful for file replay mode

    //set decay factor
    //if (replayMode == REPLAY_FILE)
    //{
    transDecayFrac = TimeUtil::timevalToDouble(updateTimeInc)
            /TimeUtil::timevalToDouble(timeWindow);
    //}

    //update the time to stop bulging points that are not condisered new
    TimeUtil::doubleToTimeval(bulgeTime, ((NEW_POINT_BULGE_USEC / 1000000.0)
                                          * timeFactor));

    emit updateReplayRateDisplay(timeFactor); //update gui

#ifdef DEBUG_DATA_PROCESSOR
    cerr << "DEBUG: replay rate set to: " << rate << endl;
#endif

#ifdef DEBUG_TRANS_DECAY
    cerr << "DEBUG: replay rate set, transparent decay fraction = "
         << transDecayFrac << '\n';
#endif

#ifdef DEBUG_NEW_POINT_BULGE
    cerr << "DEBUG: New point bulge (replay rate change):\n";
    cerr << "   replay rate = " << rate << '\n';
    cerr << "   real-time playback effect (sec) = "
         << (NEW_POINT_BULGE_USEC / 1000000.0) << '\n';
    cerr << "   realtive bulge time = "
         << TimeUtil::realativeTimevalToQString(bulgeTime) << '\n';
#endif

}


void DataProcessor::setTimeWindow(double seconds)
{
    //cater for seconds and fractions of seconds

    //get previous replayState
    int previousState = replayState;
    if (replayMode == PLAYING) //should we add the live mode?
        pause(); //this will automatically update the static display list

    if (seconds >= MIN_TIME_WINDOW && seconds >= (updateRate / 1000) && seconds <= MAX_TIME_WINDOW)
    {  //if the adjustment is to a smaller time window, file need not be re-read
        struct timeval proposedTimeWin;
        TimeUtil::doubleToTimeval(proposedTimeWin, seconds);

        if (TimeUtil::timevalGreaterThan(timeWindow, proposedTimeWin))
        {  //if old timeWindow was greater than new timeWindow
            timeWindow = proposedTimeWin;
            updateTimevals();
            if (transDecay) //re-read file to set transparency
            {  if (replayMode == REPLAY_FILE)
                    rePlot();
            }
            else //just process to remove packets off end of buffer
            {  dataExtractor.run();
            }

        }
        else
        {  //if the window size increased beyond the back end of the buffer,
            //we would have to reread the capture file to get the additional data
            //from the past
            timeWindow = proposedTimeWin;
            updateTimevals();
            if (replayMode == REPLAY_FILE)
                dataExtractor.reopenCaptureFile();
        }
        double timeWin = TimeUtil::timevalToDouble(timeWindow);

        emit updateTimeWindowDisplay(timeWin);
        //emit updateGLVisWidget();
        //glVisWidget->update();

#ifdef DEBUG_DATA_PROCESSOR
        QDateTime twEnd;
        TimeUtil::timevalToQDateTime(twEnd, timeWindowEnd);
        cerr << "DEBUG: time window set to: " << timeWindow.tv_sec
             << " seconds, and " << timeWindow.tv_usec << " microsecs\n";
        cerr << "DEBUG: time window end adjusted to: "
             << twEnd.date().toString().toLatin1().data() << ", " << twEnd.time().toString().toLatin1().data()
             << ":" << twEnd.time().msec() << endl;
#endif

    }
    else
    {  if (seconds < MIN_TIME_WINDOW)
        {  reportError("cannot set time window to less than "
                       + QString::number(MIN_TIME_WINDOW) + " seconds",
                       "DataProcessor::setTimeWindow");
        }
        if (seconds < MAX_TIME_WINDOW)
        {  reportError(("cannot set time window to " + QString::number(seconds)
                        + ", since it is more than : " + QString::number(MAX_TIME_WINDOW)
                        + " seconds (5 years)"), "DataProcessor::setTimeWindow");
        }
        if (seconds < (updateRate / 1000))
        {  reportError(("cannot set time window to less than current update rate of: "
                        + QString::number(updateRate) + " per second"),
                       "DataProcessor::setTimeWindow");
        }
    }

    //set decay factor
    if (replayMode == REPLAY_FILE)
    {
        transDecayFrac = TimeUtil::timevalToDouble(updateTimeInc)
                /TimeUtil::timevalToDouble(timeWindow);
    }

#ifdef DEBUG_TRANS_DECAY
    cerr << "DEBUG: time window set, transparent decay fraction = "
         << transDecayFrac << '\n';
#endif

    //to be safe, regenerate the static display list
    generatePointDispList();

    //resume previous replay state
    if (previousState == PLAYING)
        play();

}


void DataProcessor::setBufferAhead(double seconds)
{
    if (seconds >= MIN_BUFFER_UNDERUN_PROTECTION && seconds <= MAX_BUFFER_UNDERUN_PROTECTION)
    {  TimeUtil::doubleToTimeval(bufferAhead, seconds);
        updateTimevals();

#ifdef DEBUG_DATA_PROCESSOR
        cerr << "DEBUG: buffer underun protection set to: "
             << bufferAhead.tv_sec << " seconds, and "
             << bufferAhead.tv_usec << " microsecs\n";
#endif
    }

}


void DataProcessor::setUpdateRate(int timesPerSecond)
{
    int proposedRatePerSec = timesPerSecond;
    //check that rate is within 'reasonable' bounds
    if (proposedRatePerSec >= MIN_UPDATE_RATE && proposedRatePerSec <= MAX_UPDATE_RATE)
    {  updateRate = (int)(1000.0 / proposedRatePerSec);
        //so that replay time is updated by the correct amount, noting that
        //update rate is in millisec
        updateTimeIncrimental(updateRate);

        //check to see if timer is running, and if it is, change it
        if (processTimer->isActive()) {
            processTimer->setInterval(updateRate);
        }

        transDecayFrac = TimeUtil::timevalToDouble(updateTimeInc)
                /TimeUtil::timevalToDouble(timeWindow);

#ifdef DEBUG_DATA_PROCESSOR
        cerr << "DEBUG: update rate set to: " << updateRate << " millisec ("
             << 1000.0/updateRate << " times per sec)\n";
#endif
    }
    else
    {  //do nothing but report error
        reportError("selected update rate out of bounds",
                    "DataProcessor::setUpdateRate");
    }

#ifdef DEBUG_TRANS_DECAY
    cerr << "DEBUG: update rate set, transparent decay fraction = "
         << transDecayFrac << '\n';
#endif

}


void DataProcessor::enablePointBulge(bool on)
{
    if (newPointBulge != on) //check for state change
    {  newPointBulge = on;
        updateTimevals(); //to make sure the new point bulge stop time is updated
        //if replay state is not in play mode, need to update display list
        if (replayState != PLAYING)
            generatePointDispList();
    }

}


void DataProcessor::getBufferStatus()
{

    struct timeval timeLength; //in sec and millisec
    // Commented out below two as were assigned below but never used.
    //int nPacketEvents;
    //int bufferMemSize;

    TimeUtil::subTimevals(timeLength, timeWindowEnd, bufferPosition);
    //timeLenght = bufferposition - timeWindowEnd
    // Commented out below two lines as they are assigned but never used.
    //nPacketEvents = packetEventBuffer.size();
    //bufferMemSize = sizeof(packetEventBuffer);

#ifdef DEBUG_DATA_PROCESSOR
    cerr << "DEBUG: packet event buffer length (time) = "
         << TimeUtil::realativeTimevalToQString(timeLength).toLatin1().data() << ", events = ";

#endif

    //TODO: sort out getting info to gui

}


int DataProcessor::getMode()
{
    return replayMode;

}


int DataProcessor::getState()
{
    return replayState;

}


QDateTime *DataProcessor::getReplayPosition()
{
    return &qdt_replayPosition;

}


QDateTime *DataProcessor::getTimeWindowEnd()
{
    return &qdt_twEnd;

}


QString DataProcessor::getReplayFileName()
{
    //get the name of the replay cap file (minus the path)
    QFileInfo replayFile;
    replayFile.setFile(dataExtractor.getReplayFileName());
    QString replayFileName = replayFile.fileName();
    //remove extention from name
    int indexLastDot = replayFileName.lastIndexOf('.');
    if (indexLastDot != -1) //there was an extension
    {  replayFileName = replayFileName.remove(indexLastDot,
                                              replayFileName.length() - indexLastDot);
    }
    return replayFileName;
}

void DataProcessor::getListLocalInterfaces(QStringList *interfaces) {
    interfaces = &strAllLocalInterfaces;
}

void DataProcessor::reportHomeNetwork() {
    unsigned int netAdr = 0;
    unsigned int mask = 0;
    unsigned int shiftMask = 0;
    QString start, end, strRange;

    dataExtractor.getHomeNetwork(netAdr, mask);
    shiftMask = mask;

    int slashNum = 0;
    //keep shifting by 1 bit untill only 0s are left, in which case it evaluates
    //as false
    while (shiftMask) {
        shiftMask = shiftMask << 1;
        slashNum++;
    }

    //* //faster method below, but has byte order issues
    //do some masking and bit shifting
    unsigned int a = netAdr & 0xFF000000;
    a = a >> 24;
    unsigned int b = netAdr & 0x00FF0000;
    b = b >> 16;
    unsigned int c = netAdr & 0x0000FF00;
    c = c >> 8;
    unsigned int d = netAdr & 0x000000FF;

    //update dialog
    start = PacketHeaders::ipAdrToDecDotStr(netAdr);
    end = PacketHeaders::ipAdrToDecDotStr(netAdr|(~mask));
    //netAdr|~mask = end address in range
    strRange = start + " - " + end + " ("
            + PacketHeaders::ipAdrToDecDotStr(mask) + ')';
    if (slashNum != 0)
        emit updateHomeNetworkDisplay(a, b, c, d, slashNum, strRange);
    else
        emit updateHomeNetworkDisplay(0, 0, 0, 0, 0, strRange);
    //update text lables
    emit setXAxisLabels(start, end);
}

void DataProcessor::setHomeNetwork(int a, int b, int c, int d, int slashMask) {
    //this should be a fairly fast way to set the IP addresses using casting and
    //bit shifting

    unsigned int netAdr = 0x00000000; //also indicates start address
    unsigned int mask = 0xFFFFFFFF; //255.255.255.255
    QString start, end, strRange;

    if (slashMask == 0) {
        //full range 0.0.0.0 - 255.255.255.255
        netAdr = 0;
        mask = 0;
        dstNetFilter = "";
    }
    else {
        netAdr = (unsigned int)a;
        netAdr = netAdr << 8;
        netAdr = netAdr | (unsigned int)b;
        netAdr = netAdr << 8;
        netAdr = netAdr | (unsigned int)c;
        netAdr = netAdr << 8;
        netAdr = netAdr | (unsigned int)d;
        mask = mask << (32 - slashMask);
        //construct filter string segment for range
        dstNetFilter = "dst net " + QString::number(a) + '.' + QString::number(b)
                + '.' + QString::number(c) + '.' + QString::number(d) + '/'
                + QString::number(slashMask);
    }

    dataExtractor.setHomeNetwork(netAdr, mask);
    dataExtractor.getHomeNetwork(netAdr, mask);

    //attempt to update implicit filter
    if (updateImplicitFilter()) {
        //set x range and plot
        Plotter::setXRange((unsigned int)(netAdr),(unsigned int)(netAdr + (~mask)));
        //startAdr + NOT mask, i.e. 255.255.255.0 becomes 0.0.0.255, adding the
        //appropriate integer amount to the range
        rePlot();
        //update dialog
        start = PacketHeaders::ipAdrToDecDotStr(netAdr);
        end = PacketHeaders::ipAdrToDecDotStr(netAdr|(~mask));
        //netAdr|~mask = end address in range
        strRange = start + " - " + end + " ("
                + PacketHeaders::ipAdrToDecDotStr(mask) + ')';
        if (slashMask != 0) {
            emit updateHomeNetworkDisplay(a, b, c, d, slashMask, strRange);
        } else {
            emit updateHomeNetworkDisplay(0, 0, 0, 0, 0, strRange);
        }
        //update text lables
        emit setXAxisLabels(start, end);

#ifdef DEBUG_IMPLICIT_FILTER
        cerr << "DEBUG: destination home net = "
             << PacketHeaders::ipAdrToDecDotStr(netAdr) << ", mask = "
             << PacketHeaders::ipAdrToDecDotStr(mask) << endl;
        cerr << "   " << dataExtractor.getImplicitFilter()
             << " added to implicit filter" << endl;

#endif
    }
    else {
        //error message
        reportError("Unable to set source network range due to implicit filter error",
                    "DataProcessor::setSourceNetwork()");
    }
}

void DataProcessor::setHomeNetwork(unsigned int netAdr, unsigned int netMask) {
    int mask = netMask;
    int slashNum = 0;

    //keep shifting by 1 bit untill only 0s are left, in which case it evaluates
    //as false
    while(mask) {
        mask = mask << 1;
        slashNum++;
    }

    //* //faster method below, but has byte order issues
    //do some masking and bit shifting
    unsigned int a = netAdr & 0xFF000000;
    a = a >> 24;
    unsigned int b = netAdr & 0x00FF0000;
    b = b >> 16;
    unsigned int c = netAdr & 0x0000FF00;
    c = c >> 8;
    unsigned int d = netAdr & 0x000000FF;

    setHomeNetwork(a, b, c, d, slashNum);
}


void DataProcessor::guessHomeNetwork() {
    //call DataExtractor to scan file or quary interface card
    if (!dataExtractor.lookupNetwork()) {
        reportError("Unable to guess home network",
                    "DataProcessor::guessHomeNetwork()");
    }
}


void DataProcessor::setSourceNetwork(int a, int b, int c, int d, int slashMask)
{
    //this should be a fairly fast way to set the IP addresses using casting and
    //bit shifting

    unsigned int netAdr = 0x00000000;
    unsigned int mask = 0xFFFFFFFF; //255.255.255.255
    QString start, end, strRange;

    if (slashMask == 0) //full range 0.0.0.0 - 255.255.255.255
    {  netAdr = 0;
        mask = 0;
        //construct filter string segment for range
        srcNetFilter = "";
    }
    else
    {  netAdr = (unsigned int)a;
        netAdr = netAdr << 8;
        netAdr = netAdr | (unsigned int)b;
        netAdr = netAdr << 8;
        netAdr = netAdr | (unsigned int)c;
        netAdr = netAdr << 8;
        netAdr = netAdr | (unsigned int)d;
        mask = mask << (32 - slashMask);
        //construct filter string segment for range
        srcNetFilter = "src net " + QString::number(a) + '.' + QString::number(b)
                + '.' + QString::number(c) + '.' + QString::number(d) + '/'
                + QString::number(slashMask);
    }

    //attempt to update implicit filter
    if (updateImplicitFilter())
    {  //set z range and plot
        Plotter::setZRange((unsigned int)(netAdr),(unsigned int)(netAdr + (~mask)));
        //startAdr + NOT mask, i.e. 255.255.255.0 becomes 0.0.0.255, adding the
        //appropriate integer amount to the range
        rePlot();
        //update dialog
        start = PacketHeaders::ipAdrToDecDotStr(netAdr);
        end = PacketHeaders::ipAdrToDecDotStr(netAdr|(~mask));
        //netAdr|~mask = end address in range
        strRange = start + " - " + end + " ("
                + PacketHeaders::ipAdrToDecDotStr(mask) + ')';

        if (slashMask != 0)
            emit updateSourceNetworkDisplay(a, b, c, d, slashMask, strRange);
        else
            emit updateSourceNetworkDisplay(0, 0, 0, 0, 0, strRange);
        //update text lables
        emit setZAxisLabels(start, end);

#ifdef DEBUG_IMPLICIT_FILTER
        cerr << "DEBUG: source net = "
             << PacketHeaders::ipAdrToDecDotStr(netAdr) << ", mask = "
             << PacketHeaders::ipAdrToDecDotStr(mask) << endl;
        cerr << "   " << dataExtractor.getImplicitFilter()
             << " added to implicit filter" << endl;
#endif

    }
    else
    {  //error message
        reportError("Unable to set source network range due to implicit filter error",
                    "DataProcessor::setSourceNetwork()");
    }

}


void DataProcessor::setPortRange(int start, int end, int plotType, int logRangeBase)
{
    //function could validate range, but this is already done by the GUI

    //attempt to set filter
    portFilter = "(tcp[2:2] >= " + QString::number(start) + " and tcp[2:2] <= "
            + QString::number(end) + ") or (" + "udp[2:2] >= " + QString::number(start)
            + " and udp[2:2] <= " + QString::number(end) + ')' + " or icmp";
    //icmp must be included to avoid unintentionally filtering it out
    //if filter sucessfully set, set plotter range and replot
    if (updateImplicitFilter())
    {  Plotter::setYRange(start, end);
        Plotter::setYLogRangeBase(logRangeBase);
        if (Plotter::colMapScheme == COL_MAP_DST_PORT)  //also need to set colour range
            Plotter::setColRange(start, end);
        Plotter::yPlotScheme = plotType;
        emit setYAxisLabels(QString::number(start), QString::number(end));
        rePlot();
        //no need update GUI new value correct
    }
    else
    {  //error message
        reportError("Unable to set port range due to implicit filter error",
                    "DataProcessor::setPortRange()");
        //update GUI to old value
        emit updatePortRangeDisplay((int)Plotter::yRange[0], (int)Plotter::yRange[1]);
    }

#ifdef DEBUG_IMPLICIT_FILTER
    cerr << "DEBUG: set port range = " << Plotter::yRange[0] << '-'
         << Plotter::yRange[1];
    if (plotType == Y_PLOT_LINEAR_DST_PORT)
        cerr << " (linear plot)\n";
    else
        cerr << " (logarithmic plot)\n";
    cerr << "   " << dataExtractor.getImplicitFilter()
         << " added to implicit filter" << endl;
#endif

}


void DataProcessor::setColourScheme(int colScheme)
{
    //check for valid colour scheme choice and set the new scheme and replot

#ifdef DEBUG_DATA_PROCESSOR
    cerr << "attempting to set colour scheme to " << colScheme << '\n';
#endif

    if (colScheme == COL_MAP_DST_PORT || colScheme == COL_LOG_MAP_DST_PORT)
    {  Plotter::colMapScheme = colScheme;
        Plotter::setColLogRangeBase(Plotter::yLogRangeBase);
        Plotter::setColRange(Plotter::yRange[0], Plotter::yRange[1]); //this will
        //set to the current range of ports plotted along the y-axis
    }
    else if (colScheme == COL_MAP_SRC_PORT)
    {  Plotter::colMapScheme = colScheme;
        Plotter::setColRange(0, MAX_U_INT16_VAL); //this will set to the current
        //range of ports plotted along the y-axis
    }
    else if (colScheme == COL_MAP_SRC_ADR)
    {  Plotter::colMapScheme = colScheme;
        Plotter::setColRange(Plotter::zRange[0], Plotter::zRange[1]); //this will
        //set to the current range of source addresses plotted along the z-axis
    }
    else if (colScheme == COL_MAP_PROTO)
    {  Plotter::colMapScheme = colScheme;
        //range does not require setting
    }
    else if (colScheme == COL_MAP_PKT_SIZE || COL_LOG_MAP_PKT_SIZE)
    {  Plotter::colMapScheme = colScheme;
        Plotter::setColLogRangeBase(100.0);
        //to get about 50% colour distribution about the 20 to 100 range
        Plotter::setColRange(MIN_ETHERNET_PACKET_SIZE,
                             MAX_ETHERNET_PACKET_SIZE);
    }

    rePlot();

#ifdef DEBUG_DATA_PROCESSOR
    cerr << "colour scheme set to " << Plotter::colMapScheme << " (index), and ranges "
         << Plotter::colRange[0] << '-' << Plotter::colRange[1] << '\n';
#endif

}


void DataProcessor::setTransparentDecay(bool on)
{
    if (transDecay == on)
        return; //same state

    transDecay = on; //for data processor
    Plotter::transDecay = on; //for other classes to know state

    //set decay factor
    if (replayMode == REPLAY_FILE)
    {
        transDecayFrac = TimeUtil::timevalToDouble(updateTimeInc)
                /TimeUtil::timevalToDouble(timeWindow);
    }

#ifdef DEBUG_TRANS_DECAY
    cerr << "DEBUG: transparency toggled on/off, transparent decay fraction = "
         << transDecayFrac << '\n';
#endif

    rePlot();

}


void DataProcessor::changeBackgroundColour(int colCode)
{
    //define background colour codes
#ifndef BLACK_BACKGROUND
#define BLACK_BACKGROUND 0
#endif
#ifndef WHITE_BACKGROUND
#define WHITE_BACKGROUND 1
#endif

    //validate input
    if (colCode == BLACK_BACKGROUND)
        Plotter::backgroundCol = BLACK_BACKGROUND;
    else //assume white
        Plotter::backgroundCol = WHITE_BACKGROUND;

    //replot data
    rePlot();

    //a seperate signal will update the GLVisWidget

}


void DataProcessor::rePlot()
{
    int previousState = replayState;
    if (replayMode == PLAYING) //should we add the live mode?
        pause(); //this will automatically update the static display list

    if (replayMode == REPLAY_FILE)
    {  packetEventBuffer.clear();

        //emit updateGLVisWidget();
        //glVisWidget->update();

        dataExtractor.reopenCaptureFile();
    }
    else if (replayMode == MONITOR_LOCAL)
    {  //simply clear the buffer for live captures
        packetEventBuffer.clear();

        //emit updateGLVisWidget();
        //glVisWidget->update();
    }

    //to be safe, regenerate the static display list
    generatePointDispList();

    if (previousState == PLAYING)
        play();

}


void DataProcessor::update()
{
    //we only need to do updating when in playing mode
    if (replayState == PLAYING)
    {
        //we can hapilly apply time scaling provided we are not going beyond the
        //current time of monitoring, or the end time of a capture file

        if (replayMode == REPLAY_FILE)
        {  //since were replaying from file we can rely on incrimenting time
            //by a precalculated incrimental value - more efficent than working out
            //the time lapse every time
            TimeUtil::incTimeval(replayPosition, updateTimeInc);
            if (transDecay)
            {  transDecayNextRender = true;
            }
            //incriment the replay position and timeWindowEnd and bufferPosition
            //in accordance with the playback and update rate
        }
        else //monitoring mode
        {  //for accuracy, to keep playback and live monitoring in sync, need to
            //recalculte times for each update and adjust the values
            //according to the time lapse from the last update; replayPosition
            //premumably holds the previous updates position
            TimeUtil::qDateTimeToTimeval(currentTime, QDateTime::currentDateTime());
            TimeUtil::subTimevals(timeLapse, replayPosition, currentTime);
            //update the replay position
            TimeUtil::addTimevals(replayPosition, replayPosition, timeLapse);
            captureEndTime = currentTime; //set end time
            if (transDecay)
            {  transDecayFrac = TimeUtil::timevalToDouble(timeLapse)
                        /TimeUtil::timevalToDouble(timeWindow);
                transDecayNextRender = true;
            }
        }

        //check to see if we have reached the ending playback position
        if (TimeUtil::timevalGreaterThan(replayPosition,
                                         captureEndTime))
        {  if (replayMode == REPLAY_FILE)
            {  //been processing a file and nothing else to playback
                pause();
                setReplayPosition(captureEndTime);
            }
            else if (replayMode == MONITOR_LOCAL)
            {  //live monitor local or remote, where speedup replay from a
                //backtrack has caught up to the current position of monitoring
                setReplayRate(1.0);
                TimeUtil::qDateTimeToTimeval(currentTime,
                                             QDateTime::currentDateTime());
                TimeUtil::subTimevals(replayPosition, bufferAhead, currentTime);
                setReplayPosition(replayPosition);
            }

#ifdef DEBUG_DATA_PROCESSOR
            cerr << "DEBUG: replay position at end\n";
#endif

        }
        else //all good, were not at end so carry on processing
        {  updateTimevals();
            dataExtractor.run();
            if (transDecay) //an update so post notification to decriment opacity.
                transDecayNextRender = true;
        }

#ifdef DEBUG_DATA_UPDATE_TIMEING
        QDateTime qdt_bufPos;
        TimeUtil::timevalToQDateTime(qdt_bufPos, bufferPosition);
        cerr << "--------------------------------------------------------------------------------\n";
        cerr << "DEBUG:  buffer position: "
             << qdt_bufPos.date().toString() << ", "
             << qdt_bufPos.time().toString() << ":"
             << qdt_bufPos.time().msec() << "\n\treplay position: "
             << qdt_replayPosition.date().toString() << ", "
             << qdt_replayPosition.time().toString() << ":"
             << qdt_replayPosition.time().msec() << "\n\ttime window end: "
             << qdt_twEnd.date().toString() << ", "
             << qdt_twEnd.time().toString() << ":"
             << qdt_twEnd.time().msec() << endl << endl;
#endif

    }
    //if paused or not ready, we dont update the replay postion or time window - not true!

    emit updateGLVisWidget();
    //glVisWidget->update();

}


void DataProcessor::updateStatus()
{
    emit setStatusBarMessage("Event buffer: "
                             + QString::number(packetEventBuffer.size()));
    //buffer has two empty elements

}


void DataProcessor::generatePointDispList()
{

    //remove previous list, if it exits
    if (glIsList(staticSatterplotList))
        glDeleteLists(staticSatterplotList, 1);

    glNewList(staticSatterplotList, GL_COMPILE);

    //simply use renderDataDynamic to generate the list
    renderDataDynamic();

    glEndList();

}


void DataProcessor::renderData()
{  
    if (replayState == PLAYING)
    {  renderDataDynamic();
    }
    else // render Static display list;
    {  glCallList(staticSatterplotList);
    }

}


void DataProcessor::renderDataDynamic()
{
    //used to render during live / play mode, or to generate the display list for
    //static / paused mode

    deque<PacketEvent>::iterator itr;

    //get the first element in the deque
    itr = packetEventBuffer.begin();

    //move itterator along to beging of replay position - past buffer ahead
    //note, don't use TimeUtil::timevalGreaterThan() avoid func call
    //most recent items at front of deque, oldest at back

#ifdef DEBUG_DATA_RENDER
    cerr << "DEBUG: DataRender skipping buffer before replay position:"
         << endl;
    QDateTime dt;
    TimeUtil::timevalToQDateTime(dt, bufferPosition);
    cerr << "DEBUG: buffer position: "
         << dt.toString("yyyy/MM/dd-hh:mm:ss:zzz") << endl;
    TimeUtil::timevalToQDateTime(dt, replayPosition);
    cerr << "DEBUG: replay position: "
         << dt.toString("yyyy/MM/dd-hh:mm:ss:zzz") << endl;
    TimeUtil::timevalToQDateTime(dt, itr->timeStamp);
    cerr << "DEBUG: first event time: "
         << dt.toString("yyyy/MM/dd-hh:mm:ss:zzz") << endl << endl;

#endif


    //get to the right second
    for (itr; itr->timeStamp.tv_sec > replayPosition.tv_sec
         && itr != packetEventBuffer.end(); itr++)
    { //do nothing

#ifdef DEBUG_DATA_RENDER
        TimeUtil::timevalToQDateTime(dt, itr->timeStamp);
        cerr << "DEBUG: DataRender skipped buffered packet (by sec): "
             << dt.toString("yyyy/MM/dd-hh:mm:ss:zzz") << endl;
#endif

    }
    //get to the right microsecond
    //musr recheck second in case next packets was seconds behind, in which case
    //the usec doesn't matter
    for (itr; itr->timeStamp.tv_sec == replayPosition.tv_sec
         && itr->timeStamp.tv_usec > replayPosition.tv_usec
         && itr != packetEventBuffer.end(); itr++)
    { //do nothing

#ifdef DEBUG_DATA_RENDER
        TimeUtil::timevalToQDateTime(dt, itr->timeStamp);
        cerr << "DEBUG: DataRender skipped buffered packet (by usec): "
             << dt.toString("yyyy/MM/dd-hh:mm:ss:zzz") << endl;
#endif

    }

    //now at replay position

#ifdef DEBUG_DATA_RENDER
    cerr << "\nDEBUG: DataRender skipped buffer up to replay position:"
         << endl;
    TimeUtil::timevalToQDateTime(dt, bufferPosition);
    cerr << "DEBUG: buffer position: "
         << dt.toString("yyyy/MM/dd-hh:mm:ss:zzz") << endl;
    TimeUtil::timevalToQDateTime(dt, replayPosition);
    cerr << "DEBUG: replay position: "
         << dt.toString("yyyy/MM/dd-hh:mm:ss:zzz") << endl;
    TimeUtil::timevalToQDateTime(dt, itr->timeStamp);
    cerr << "DEBUG: current event time: "
         << dt.toString("yyyy/MM/dd-hh:mm:ss:zzz") << endl;
    if (itr == packetEventBuffer.end())
        cerr << "DEBUG: deque itterator at end already!\n";
    cerr << endl;
#endif

    //check if we are bulging/pulsing new points/packets
    if (newPointBulge)
    {
        float pointSize[1];
        bool newPoints = true;

        glGetFloatv(GL_POINT_SIZE, pointSize);
        glPointSize(pointSize[0] + 1.0); //bulge point size

#ifdef DEBUG_NEW_POINT_BULGE
        cerr << "DEBUG: New point bulge (data render):\n";
        cerr << "   normal point size = " << pointSize[0]
             << ", bulged point size = "<< (pointSize[0] + 1.0) << '\n';
#endif

        //now draw new points slightly bulged
        glBegin(GL_POINTS);

        //keep drawing bulged points untill points are not considered new
        for (itr; newPoints && itr != packetEventBuffer.end(); itr++)
        {
            //check if we reached time to stop bulging points
            if (stopBulgeTime.tv_sec > itr->timeStamp.tv_sec)
            {  //already over a second beyond the time
                newPoints = false; //done bulging new points
                itr--; //cause we overstepped by 1
            }
            else if (stopBulgeTime.tv_usec == itr->timeStamp.tv_usec
                     && stopBulgeTime.tv_usec > itr->timeStamp.tv_usec)
            {  //within the second, check the msec
                newPoints = false; //done bulging new points
                itr--; //cause we overstepped by 1
            }
            else //still drawing and bulging new points
            {

                //if (itr->graphicElement != NULL) //de we need this check?
                //{

                //set points colour
                glColor4fv((GLfloat*)itr->point.colour);
                //render point
                glVertex3fv((GLfloat*)itr->point.coord);

#ifdef DEBUG_DATA_RENDER_PLOT
                cerr << "DEBUG: Graphic Element rendered at: x="
                     << itr->point.coord[0] << ", y=" << itr->point.coord[1]
                     << ", z=" << itr->point.coord[2] << endl;
                TimeUtil::timevalToQDateTime(dt, itr->timeStamp);
                cerr << "DEBUG: for time: "
                     << dt.toString("yyyy/MM/dd-hh:mm:ss:zzz") << endl << endl;
#endif

#ifdef DEBUG_NEW_POINT_BULGE
                QDateTime ts;
                TimeUtil::timevalToQDateTime(ts, itr->timeStamp);
                cerr << "   point bulge at time stamp  =  "
                     << ts.toString("yyyy/MM/dd-hh:mm:ss:zzz") << '\n';
#endif

                //remember do transparency decrerments on the fly - this is done both
                //for new points and non-new points
                //note transDecayNextRender is set
                //in another function DataProcessor::update()
                if (transDecayNextRender)
                {  itr->point.colour[3] -= transDecayFrac;
                }

                /*}
            else
            {
               #ifdef DEBUG_DATA_RENDER
                  cerr << "DEBUG: NULL graphic element\n";
               #endif
            } //*/

            }

        }

        //set points back to default size
        glEnd(); //can't change point size unless glBegin call is ended
        glPointSize(pointSize[0]);


#ifdef DEBUG_NEW_POINT_BULGE
        cerr << "   !END of new points reached, setting point size to "
             << pointSize[0] << '\n';
#endif

    }

    //draw all/remaining default sized points till at the end of the deque which
    //representes the end of the time-window

    glBegin(GL_POINTS);

    for (itr; itr != packetEventBuffer.end(); itr++)
    {
        //if (itr->graphicElement != NULL) //do we need this check
        //{

        //set points colour
        glColor4fv((GLfloat*)itr->point.colour);
        //render point
        glVertex3fv((GLfloat*)itr->point.coord);

#ifdef DEBUG_DATA_RENDER_PLOT
        cerr << "DEBUG: Graphic Element rendered at: x="
             << itr->point.coord[0] << ", y=" << itr->point.coord[1]
             << ", z=" << itr->point.coord[2] << endl;
        TimeUtil::timevalToQDateTime(dt, itr->timeStamp);
        cerr << "DEBUG: for time: " << dt.toString("yyyy/MM/dd-hh:mm:ss:zzz")
             << endl << endl;
#endif

        //remember do transparency decrerments on the fly - this is done both
        //for new points and non-new points
        if (transDecayNextRender)
        {  itr->point.colour[3] -= transDecayFrac;
        }

        /*}
      else
      {
         #ifdef DEBUG_DATA_RENDER
            cerr << "DEBUG: NULL graphic element\n";
         #endif
      } //*/

    }

    glEnd();

    //done performing update to transparency, avoid doing it when updates are
    //not in conjucntion with time advances - note transDecayNextRender is set
    //in another function DataProcessor::update()
    if(transDecayNextRender)
        transDecayNextRender = false;

    /*
   //ensure point size is returned to normal (as may be required case when all
   //points are new
   if (newPoints)
   {  glPointSize(pointSize[0]);

      #ifdef DEBUG_NEW_POINT_BULGE
            cerr << "   point size returned to " << pointSize[0] << '\n';
      #endif
   }
*/

}


void DataProcessor::reportError(const QString &errMsg, const QString &function) {
    QString errorMessage;
    errorMessage.append("ERROR: ");
    errorMessage.append(errMsg);
    if (function.isNull()) {
        errorMessage.append("\n - in function: ");
        errorMessage.append(function);
    }
    errorMessage.append("\n");

#ifdef OUTPUT_ERRORS_STD_OUT
    Log::logError(errorMessage);
#elif DEBUG_DATA_PROCESSOR
    Log::logError(errorMessage);
#endif

    //ensure timer is reset so that error is displayed for 1 seconds
    statusTimer->stop();
    statusTimer->start(1000);

    emit setStatusBarMessage("ERROR!");

#ifdef OUTPUT_ERRORS_GUI
    emit sendErrMsg(errorMessage);
#endif
}

QString DataProcessor::getRecordDir() {   
    QSettings settings;
    return settings.value(RECORD_DEFAULT_DIR_KEY).toString();
}

void DataProcessor::setRecordDir(QString recordDir) {
    QSettings settings;
    settings.setValue(RECORD_DEFAULT_DIR_KEY, recordDir);
}

bool DataProcessor::isRecordDirSet() {
    QSettings settings;
    return settings.contains(RECORD_DEFAULT_DIR_KEY);
}

QString DataProcessor::getPcapsDir() {    
    QSettings settings;
    return settings.value(RECORD_PCAPS_SUBDIR_KEY).toString();
}

void DataProcessor::setPcapsDir(QString pcapsDir) {
    QSettings settings;
    settings.setValue(RECORD_PCAPS_SUBDIR_KEY, pcapsDir);
}

bool DataProcessor::isPcapsDirSet() {
    QSettings settings;
    return settings.contains(RECORD_PCAPS_SUBDIR_KEY);
}

QString DataProcessor::getFramesDir() {
    QSettings settings;
    return settings.value(RECORD_FRAMES_SUBDIR_KEY).toString();
}

void DataProcessor::setFramesDir(QString framesDir) {
    QSettings settings;
    settings.setValue(RECORD_FRAMES_SUBDIR_KEY, framesDir);
}

bool DataProcessor::isFramesDirSet() {
    QSettings settings;
    return settings.contains(RECORD_FRAMES_SUBDIR_KEY);
}

QString DataProcessor::getSnapshotsDir() {
    QSettings settings;
    return settings.value(RECORD_SNAPSHOTS_SUBDIR_KEY).toString();
}

void DataProcessor::setSnapshotsDir(QString snapshotsDir) {    
    QSettings settings;
    settings.setValue(RECORD_SNAPSHOTS_SUBDIR_KEY, snapshotsDir);
}

bool DataProcessor::isSnapshotDirSet() {
    QSettings settings;
    return settings.contains(RECORD_SNAPSHOTS_SUBDIR_KEY);
}

QString DataProcessor::getLiveSubdir() {
    QSettings settings;
    return settings.value(RECORD_LIVE_SUBDIR_KEY).toString();
}

void DataProcessor::setLiveSubdir(QString liveSubdir) {
    QSettings settings;
    settings.setValue(RECORD_LIVE_SUBDIR_KEY, liveSubdir);
}

bool DataProcessor::isLiveSubdirSet() {
    QSettings settings;
    return settings.contains(RECORD_LIVE_SUBDIR_KEY);
}

QString DataProcessor::getReplaySubdir() {
    QSettings settings;
    return settings.value(RECORD_REPLAY_SUBDIR_KEY).toString();
}

void DataProcessor::setReplaySubdir(QString replaySubdir) {
    QSettings settings;
    settings.setValue(RECORD_REPLAY_SUBDIR_KEY, replaySubdir);
}

bool DataProcessor::isReplaySubdirSet() {
    QSettings settings;
    return settings.contains(RECORD_REPLAY_SUBDIR_KEY);
}

QString DataProcessor::getDefaultHomeNetwork() {
    QSettings settings;
    return settings.value(DEFAULT_HOME_NETWORK_KEY).toString();
}

bool DataProcessor::setDefaultHomeNetwork(QString ipAddress) {
    QStringList ipAndMask = ipAddress.split('/');

    // If the list length is less than 2, it's invalid, return false.
    if (ipAndMask.length() < 2) {
        return false;
    }

    QString ip = ipAndMask.at(0);
    QStringList octets = ip.split(".");

    // If the IP address is malformed, return false.
    if (octets.length() != 4) {
        return false;
    }

    int octA = octets.at(0).toInt();
    int octB = octets.at(1).toInt();
    int octC = octets.at(2).toInt();
    int octD = octets.at(3).toInt();

    // Ensure the octets are actual IP address octets.
    // This isn't elegant, should be improved.
    if (octA < 0 || octA > 255) {
        return false;
    }
    if (octB < 0 || octB > 255) {
        return false;
    }
    if (octC < 0 || octC > 255) {
        return false;
    }
    if (octD < 0 || octD > 255) {
        return false;
    }

    QString mask = ipAndMask.at(1);
    int maskInt = mask.toInt();

    if (maskInt < 0 || maskInt > 32) {
        return false;
    }

    return DataProcessor::setDefaultHomeNetwork(octA, octB, octC, octD, maskInt);
}

bool DataProcessor::setDefaultHomeNetwork(int octA, int octB, int octC, int octD, int slashMask) {
    QString ipAddress = QString::number(octA) + "."
            + QString::number(octB) + "."
            + QString::number(octC) + "."
            + QString::number(octD) + "/"
            + QString::number(slashMask);
    QSettings settings;
    settings.setValue(DEFAULT_HOME_NETWORK_KEY, ipAddress);
    return true;
}

bool DataProcessor::isDefaultHomeNetworkSet() {
    QSettings settings;
    return settings.contains(DEFAULT_HOME_NETWORK_KEY);
}

bool DataProcessor::getShowHomeNetworkNotSetError() {
    QSettings settings;
    return settings.value(SHOW_HOME_NETWORK_NOT_SET_ERROR_KEY).toBool();
}

void DataProcessor::setShowHomeNetworkNotSetError(bool show) {
    QSettings settings;
    settings.setValue(SHOW_HOME_NETWORK_NOT_SET_ERROR_KEY, show);
}

bool DataProcessor::isShowHomeNetworkNotSetError() {
    QSettings settings;
    return settings.contains(SHOW_HOME_NETWORK_NOT_SET_ERROR_KEY);
}

QString DataProcessor::getDefaultMonitorInterface() {
    QSettings settings;
    return settings.value(DEFAULT_MONITOR_INTERFACE_KEY).toString();
}

void DataProcessor::setDefaultMonitorInterface(QString monitorInterface) {
    QSettings settings;
    settings.setValue(DEFAULT_MONITOR_INTERFACE_KEY, monitorInterface);
}

bool DataProcessor::isDefaultMonitorInterfaceSet() {
    QSettings settings;
    return settings.contains(DEFAULT_MONITOR_INTERFACE_KEY);
}

QString DataProcessor::getScreenshotFormat() {
    QSettings settings;
    return settings.value(SCREENSHOT_FORMAT_KEY).toString();
}

void DataProcessor::setScreenshotFormat(QString screenshotFormat) {
    QSettings settings;
    settings.setValue(SCREENSHOT_FORMAT_KEY, screenshotFormat);
}

bool DataProcessor::isScreenshotFormatSet() {
    QSettings settings;
    return settings.contains(SCREENSHOT_FORMAT_KEY);
}

QString DataProcessor::getScreenshotExtension() {
    QSettings settings;
    return settings.value(SCREENSHOT_EXTENSION_KEY).toString();
}

void DataProcessor::setScreenshotExtension(QString screenshotExtension) {
    QSettings settings;
    settings.setValue(SCREENSHOT_EXTENSION_KEY, screenshotExtension);
}

bool DataProcessor::isScreenshotExtensionSet() {
    QSettings settings;
    return settings.contains(SCREENSHOT_EXTENSION_KEY);
}

int DataProcessor::getScreenshotQuality() {
    QSettings settings;
    return settings.value(SCREENSHOT_QUALITY_KEY).toInt();
}

void DataProcessor::setScreenshotQuality(int screenshotQuality) {
    QSettings settings;
    settings.setValue(SCREENSHOT_QUALITY_KEY, screenshotQuality);
}

bool DataProcessor::isScreenshotQualitySet() {
    QSettings settings;
    return settings.contains(SCREENSHOT_QUALITY_KEY);
}

void DataProcessor::resetVisualisationPlane() {
    //if currently playing, pause
    bool was_playing = false;
    if (getState() == PLAYING) {
        pause();
        was_playing = true;
    }

    packetEventBuffer.clear();
    updateGLVisWidget();

    // Only start playing again if current state is paused, it was playing
    if (getState() == PAUSED && was_playing) {
        play();
    }
}
